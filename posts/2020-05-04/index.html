<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solving for the Jacobians of a Robot Leg | Ben Bokser</title><meta name=keywords content><meta name=description content="I&rsquo;m currently working on the Python code to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf&rsquo;s incredibly helpful blog). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this."><meta name=author content="Ben Bokser"><link rel=canonical href=https://bbokser.github.io/posts/2020-05-04/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbokser.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://bbokser.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://bbokser.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://bbokser.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://bbokser.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js integrity=sha384-+BSz3oj3ILMYvOBr16U9i0H4RZRmGyQQ+1q9eqr8T3skmAFrJk8GmgwgqlCZdNSo crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><meta property="og:title" content="Solving for the Jacobians of a Robot Leg"><meta property="og:description" content="I&rsquo;m currently working on the Python code to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf&rsquo;s incredibly helpful blog). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this."><meta property="og:type" content="article"><meta property="og:url" content="https://bbokser.github.io/posts/2020-05-04/"><meta property="article:section" content="posts"><meta property="og:site_name" content="Ben Bokser's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solving for the Jacobians of a Robot Leg"><meta name=twitter:description content="I&rsquo;m currently working on the Python code to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf&rsquo;s incredibly helpful blog). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbokser.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Solving for the Jacobians of a Robot Leg","item":"https://bbokser.github.io/posts/2020-05-04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solving for the Jacobians of a Robot Leg","name":"Solving for the Jacobians of a Robot Leg","description":"I\u0026rsquo;m currently working on the Python code to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf\u0026rsquo;s incredibly helpful blog). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this.","keywords":[],"articleBody":"I’m currently working on the Python code to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf’s incredibly helpful blog). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this. There really aren’t enough resources on the internet that explain this in a succinct manner.\nAn earlier mechanical design. Kinematic diagram. Solving for the transformation matrices and centers of motion correctly is the trickiest part of the process, and deceptively so. For more information on how to set up the transformation matrices, I recommend this Youtube tutorial and this blog post.\nI find it easiest to solve for the transformation matrices by “stringing” the robot out, as shown below, such that all of the joints’ coordinate systems are oriented the same way. This saves you from having to perform additional linear algebra operations, which would raise your chances of making a mistake.\nShown below are the transformation matrices. The first transformation represents an x-axis rotation. See the first joint in the kinematic diagram above for reference. Transformations (2) through (4) are z-axis rotations. Despite the z-axis pointing up in the world coordinate system, the default angle (90 degrees) for the first x-axis rotation points the z-axis of the second through fourth joints parallel to the y-axis of the WCS.\n$${org}^0 T = $$ $$ \\begin{equation} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\newline 0 \u0026 \\cos{(q{0})} \u0026 - \\sin{(q_{0})} \u0026 L_{0}\\cos{(q_{0})} \\newline 0 \u0026 \\sin{(q_{0})} \u0026 \\cos{(q_{0})} \u0026 L_{0}\\sin{(q_{0})} \\newline 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{equation} $$ $$ \\begin{equation} 0^1 T = \\begin{bmatrix} \\cos{(q{1} )} \u0026 - \\sin{(q_{1} )} \u0026 0 \u0026 -L_{1} \\sin{(q_{1} )}\\newline \\sin{(q_{1} )} \u0026 \\cos{(q_{1} )} \u0026 0 \u0026 L_{1} \\cos{(q_{1} )}\\newline 0 \u0026 0 \u0026 1 \u0026 0\\newline 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{equation} $$ $$ \\begin{equation} 1^2 T = \\begin{bmatrix} \\cos{(q{2} )} \u0026 - \\sin{(q_{2} )} \u0026 0 \u0026 -L_{2} \\sin{(q_{2} )}\\newline \\sin{(q_{2} )} \u0026 \\cos{(q_{2} )} \u0026 0 \u0026 L_{2} \\cos{(q_{2} )}\\newline 0 \u0026 0 \u0026 1 \u0026 0\\newline 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{equation} $$ $$ \\begin{equation} 2^3 T = \\begin{bmatrix} \\cos{(q{3} )} \u0026 - \\sin{(q_{3} )} \u0026 0 \u0026 -L_{3} \\sin{(q_{3} )}\\newline \\sin{(q_{3} )} \u0026 \\cos{(q_{3} )} \u0026 0 \u0026 L_{3} \\cos{(q_{3} )}\\newline 0 \u0026 0 \u0026 1 \u0026 0\\newline 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{equation} $$\nNext, the locations for the centers of mass at each link are found, where $l_0$, $l_1$, $l_2$, and $l_3$ represent the distance of the center of mass from the base joint of each link, along a line connecting the base joint to the next joint. Keep in mind that the centers of mass may not be located directly along a line from one joint to the next in any given robot link, and that in this case I am able to make this approximation for the purpose of mathematical simplicity.\n$$ \\begin{equation} com_0 = \\begin{bmatrix} 0\\newline l_{0} \\cos{(q_{0} )}\\newline l_{0} \\sin{(q_{0} )}\\newline 1 \\end{bmatrix} \\end{equation} $$\n$$ \\begin{equation} com_1 = \\begin{bmatrix} {-l_{1} \\sin{(q_{1} )}}\\newline l_{1} \\cos{(q_{1} )}\\newline 0\\newline 1 \\end{bmatrix} \\end{equation} $$\n$$ \\begin{equation} com_2 = \\begin{bmatrix} -l_{2} \\sin{(q_{2} )}\\newline l_{2} \\cos{(q_{2} )}\\newline 0\\newline 1 \\end{bmatrix} \\end{equation} $$\n$$ \\begin{equation} com_3 = \\begin{bmatrix} -l_{3} \\sin{(q_{3} )}\\newline l_{3} \\cos{(q_{3} )}\\newline 0\\newline 1 \\end{bmatrix} \\end{equation} $$\nThe end-effector offset (Equation 9) should also be kept in mind, but in my case I don’t need an offset from the end-effector. As such, I’m expressing it as zero.\n$$ \\begin{equation} x_{ee} = \\begin{bmatrix} 0\\newline 0\\newline 0\\newline 1 \\end{bmatrix} \\end{equation} $$\nNext, I solved for the full transformation matrices from the origin to each joint. This isn’t necessary for the first joint, because it’s already in the base coordinate system.\n$$ \\begin{equation} _{org}^1 T = _{org}^0 T _0^1 T \\end{equation} $$\n$$ \\begin{equation} _{org}^2 T = _{org}^0 T _0^1 T _1^2 T \\end{equation} $$\n$$ \\begin{equation} _{org}^3 T = _{org}^0 T _0^1 T _1^2 T _2^3 T \\end{equation} $$\nNow, the Jacobian for each COM and the end-effector can be found as a matrix of its partial derivatives with respect to each joint qᵢ. Both linear and angular velocities must be accounted for, so I have $x$, $y$, $z$, $\\omega_x$, $\\omega_y$, $\\omega_z$ to deal with.\n$$ \\begin{equation} Jacobian = \\begin{bmatrix} \\frac{\\partial x}{\\partial q_0} \u0026 \\frac{\\partial x}{\\partial q_1} \u0026 \\frac{\\partial x}{\\partial q_2} \u0026 \\frac{\\partial x}{\\partial q_3}\\newline \\frac{\\partial y}{\\partial q_0} \u0026 \\frac{\\partial y}{\\partial q_1} \u0026 \\frac{\\partial y}{\\partial q_2} \u0026 \\frac{\\partial y}{\\partial q_3}\\newline \\frac{\\partial z}{\\partial q_0} \u0026 \\frac{\\partial z}{\\partial q_1} \u0026 \\frac{\\partial z}{\\partial q_2} \u0026 \\frac{\\partial z}{\\partial q_3}\\newline \\frac{\\partial \\omega_x}{\\partial q_0} \u0026 \\frac{\\partial \\omega_x}{\\partial q_1} \u0026 \\frac{\\partial \\omega_x}{\\partial q_2} \u0026 \\frac{\\partial \\omega_x}{\\partial q_3}\\newline \\frac{\\partial \\omega_y}{\\partial q_0} \u0026 \\frac{\\partial \\omega_y}{\\partial q_1} \u0026 \\frac{\\partial \\omega_y}{\\partial q_2} \u0026 \\frac{\\partial \\omega_y}{\\partial q_3}\\newline \\frac{\\partial \\omega_z}{\\partial q_0} \u0026 \\frac{\\partial \\omega_z}{\\partial q_1} \u0026 \\frac{\\partial \\omega_z}{\\partial q_2} \u0026 \\frac{\\partial \\omega_z}{\\partial q_3}\\newline \\end{bmatrix} \\end{equation} $$\nSo far I haven’t explained angular velocity. This I have solved separately, and it’s quite simple as long as your robot is serial and doesn’t have spherical joints. The partial derivative for the angular velocity w.r.t. each joint is expressed as 1 if that joint rotates along that axis, and 0 if it doesn’t. For example, in J₀ (Equation 14), joint q₀ rotates around the x axis, so the partial derivative of $\\omega_x$ w.r.t. $q_0$ is 1. In $J_1$ (Equation 15), joint $q_1$ rotates about the z axis, so the partial derivative of $\\omega_z$ w.r.t. $q_1$ is 1.\n$$ \\begin{equation} J_0 = Jacobian(com_0) = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \u0026 0\\newline - l_{0} \\sin{(q_{0} )} \u0026 0 \u0026 0 \u0026 0\\newline l_{0} \\cos{(q_{0} )} \u0026 0 \u0026 0 \u0026 0\\newline 1 \u0026 0 \u0026 0 \u0026 0\\newline 0 \u0026 0 \u0026 0 \u0026 0\\newline 0 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} \\end{equation} $$\nI can only show the first two Jacobians here, as the rest are too long to fit on the screen. You’ll notice that the Jacobians for the centers of motion of each link ($J_0$, $J_1$, $J_2$, and $J_3$) are calculated as a function of the transformation matrix from the link’s base joint to the origin multiplied by that link’s center of motion. This confused me the first time around, and I don’t want you, the reader, to make the same mistake.\nFor example, in the case of $J_1$ (the Jacobian for the second link), the transformation matrix from joint 0 to the world coordinate frame (origin) is multiplied by $com_1$, the center of motion of the link between joints 0 and 1 (the first and second joints, so the second link).\nFor $J_0$ (the Jacobian for the first link), no transformation matrix is required because the first joint ($q_0$) is already in the base coordinate system.\nI’m probably just confusing you more because my joint indexing starts at zero, but that’s for programming purposes and is standard…\n$$ J_1 = Jacobian(_{org}^0 T com_1) = $$\n$$ \\begin{equation} \\begin{bmatrix} 0 \u0026 - l_{1} \\cos{(q_{1} )} \u0026 0 \u0026 0 \\newline - (L_{0} + l_{1} \\cos{(q_{1} )}) \\sin{(q_{0} )} \u0026 - l_{1} \\sin{(q_{1} )} \\cos{(q_{0} )} \u0026 0 \u0026 0 \\newline (L_{0} + l_{1} \\cos{(q_{1} )}) \\cos{(q_{0} )} \u0026 - l_{1} \\sin{(q_{0} )} \\sin{(q_{1} )} \u0026 0 \u0026 0 \\newline 1 \u0026 0 \u0026 0 \u0026 0 \\newline 0 \u0026 0 \u0026 0 \u0026 0 \\newline 0 \u0026 1 \u0026 0 \u0026 0 \\end{bmatrix} \\end{equation} $$\n$$ \\begin{equation} J_2 = Jacobian(_{org}^1 T com_2) \\end{equation} $$\n$$ \\begin{equation} J_3 = Jacobian(_{org}^2 T com_3) \\end{equation} $$\n$$ \\begin{equation} J_{EE} = Jacobian({org}^3 T x{ee}) \\end{equation} $$\nSo there you have it. After several headaches, I was able to verify that this setup works in simulation. The chief cause of my problems was that I had solved for the transformation matrices incorrectly! Everything else is easy–though it looks intimidating, all of the symbolic math can be computationally solved by Matlab/Octave. Just remember, garbage in = garbage out.\n","wordCount":"1345","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ben Bokser"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbokser.github.io/posts/2020-05-04/"},"publisher":{"@type":"Organization","name":"Ben Bokser","logo":{"@type":"ImageObject","url":"https://bbokser.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbokser.github.io/ accesskey=h title="Ben Bokser (Alt + H)">Ben Bokser</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbokser.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://bbokser.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bbokser.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://bbokser.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://benbokser.com/ title=Portfolio><span>Portfolio</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbokser.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbokser.github.io/posts/>Posts</a></div><h1 class=post-title>Solving for the Jacobians of a Robot Leg</h1><div class=post-meta>7 min&nbsp;·&nbsp;Ben Bokser&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2020-05-04.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I&rsquo;m currently working on the Python <a href=https://github.com/bbokser/spryped>code</a> to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf&rsquo;s incredibly helpful <a href=https://studywolf.wordpress.com/site-index/>blog</a>). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this. There really aren&rsquo;t enough resources on the internet that explain this in a succinct manner.</p><table><thead><tr><th style=text-align:center>An earlier mechanical design.</th><th style=text-align:center>Kinematic diagram.</th></tr></thead><tbody><tr><td style=text-align:center><img loading=lazy src=/images/chickenwalker-orig.jpg alt="Mechanical Design"></td><td style=text-align:center><img loading=lazy src=/images/kinematicdiagram1.png alt="Kinematic Diagram"></td></tr></tbody></table><p>Solving for the transformation matrices and centers of motion correctly is the trickiest part of the process, and deceptively so. For more information on how to set up the transformation matrices, I recommend this Youtube tutorial and this <a href=https://studywolf.wordpress.com/2017/06/09/deriving-a-robots-transform-matrices/>blog post</a>.</p><p>I find it easiest to solve for the transformation matrices by &ldquo;stringing&rdquo; the robot out, as shown below, such that all of the joints&rsquo; coordinate systems are oriented the same way. This saves you from having to perform additional linear algebra operations, which would raise your chances of making a mistake.</p><p><img loading=lazy src=/images/kinematicdiagram-2_orig.png alt="Kinematic Diagram 2"></p><p>Shown below are the transformation matrices. The first transformation represents an x-axis rotation. See the first joint in the kinematic diagram above for reference. Transformations (2) through (4) are z-axis rotations. Despite the z-axis pointing up in the world coordinate system, the default angle (90 degrees) for the first x-axis rotation points the z-axis of the second through fourth joints parallel to the y-axis of the WCS.</p><p>$$<em>{org}^0 T = $$
$$
\begin{equation}
\begin{bmatrix}
1 & 0 & 0 & 0 \newline
0 & \cos{(q</em>{0})} & - \sin{(q_{0})} & L_{0}\cos{(q_{0})} \newline
0 & \sin{(q_{0})} & \cos{(q_{0})} & L_{0}\sin{(q_{0})} \newline
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}
$$
$$
\begin{equation}
<em>0^1 T = \begin{bmatrix}
\cos{(q</em>{1} )} & - \sin{(q_{1} )} & 0 & -L_{1} \sin{(q_{1} )}\newline
\sin{(q_{1} )} & \cos{(q_{1} )} & 0 & L_{1} \cos{(q_{1} )}\newline
0 & 0 & 1 & 0\newline
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}
$$
$$
\begin{equation}
<em>1^2 T = \begin{bmatrix}
\cos{(q</em>{2} )} & - \sin{(q_{2} )} & 0 & -L_{2} \sin{(q_{2} )}\newline
\sin{(q_{2} )} & \cos{(q_{2} )} & 0 & L_{2} \cos{(q_{2} )}\newline
0 & 0 & 1 & 0\newline
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}
$$
$$
\begin{equation}
<em>2^3 T = \begin{bmatrix}
\cos{(q</em>{3} )} & - \sin{(q_{3} )} & 0 & -L_{3} \sin{(q_{3} )}\newline
\sin{(q_{3} )} & \cos{(q_{3} )} & 0 & L_{3} \cos{(q_{3} )}\newline
0 & 0 & 1 & 0\newline
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}
$$</p><p>Next, the locations for the centers of mass at each link are found, where $l_0$, $l_1$, $l_2$, and $l_3$ represent the distance of the center of mass from the base joint of each link, along a line connecting the base joint to the next joint. Keep in mind that the centers of mass may not be located directly along a line from one joint to the next in any given robot link, and that in this case I am able to make this approximation for the purpose of mathematical simplicity.</p><p>$$
\begin{equation}
com_0 = \begin{bmatrix}
0\newline
l_{0} \cos{(q_{0} )}\newline
l_{0} \sin{(q_{0} )}\newline
1
\end{bmatrix}
\end{equation}
$$</p><p>$$
\begin{equation}
com_1 = \begin{bmatrix}
{-l_{1} \sin{(q_{1} )}}\newline
l_{1} \cos{(q_{1} )}\newline
0\newline
1
\end{bmatrix}
\end{equation}
$$</p><p>$$
\begin{equation}
com_2 = \begin{bmatrix}
-l_{2} \sin{(q_{2} )}\newline
l_{2} \cos{(q_{2} )}\newline
0\newline
1
\end{bmatrix}
\end{equation}
$$</p><p>$$
\begin{equation}
com_3 = \begin{bmatrix}
-l_{3} \sin{(q_{3} )}\newline
l_{3} \cos{(q_{3} )}\newline
0\newline
1
\end{bmatrix}
\end{equation}
$$</p><p>The end-effector offset (Equation 9) should also be kept in mind, but in my case I don&rsquo;t need an offset from the end-effector. As such, I&rsquo;m expressing it as zero.</p><p>$$
\begin{equation}
x_{ee} = \begin{bmatrix}
0\newline
0\newline
0\newline
1
\end{bmatrix}
\end{equation}
$$</p><p>Next, I solved for the full transformation matrices from the origin to each joint. This isn&rsquo;t necessary for the first joint, because it&rsquo;s already in the base coordinate system.</p><p>$$
\begin{equation}
_{org}^1 T = _{org}^0 T _0^1 T
\end{equation}
$$</p><p>$$
\begin{equation}
_{org}^2 T = _{org}^0 T _0^1 T _1^2 T
\end{equation}
$$</p><p>$$
\begin{equation}
_{org}^3 T = _{org}^0 T _0^1 T _1^2 T _2^3 T
\end{equation}
$$</p><p>Now, the Jacobian for each COM and the end-effector can be found as a matrix of its partial derivatives with respect to each joint qᵢ. Both linear and angular velocities must be accounted for, so I have $x$, $y$, $z$, $\omega_x$, $\omega_y$, $\omega_z$ to deal with.</p><p>$$
\begin{equation}
Jacobian =
\begin{bmatrix}
\frac{\partial x}{\partial q_0} & \frac{\partial x}{\partial q_1} & \frac{\partial x}{\partial q_2} & \frac{\partial x}{\partial q_3}\newline
\frac{\partial y}{\partial q_0} & \frac{\partial y}{\partial q_1} & \frac{\partial y}{\partial q_2} & \frac{\partial y}{\partial q_3}\newline
\frac{\partial z}{\partial q_0} & \frac{\partial z}{\partial q_1} & \frac{\partial z}{\partial q_2} & \frac{\partial z}{\partial q_3}\newline
\frac{\partial \omega_x}{\partial q_0} & \frac{\partial \omega_x}{\partial q_1} & \frac{\partial \omega_x}{\partial q_2} & \frac{\partial \omega_x}{\partial q_3}\newline
\frac{\partial \omega_y}{\partial q_0} & \frac{\partial \omega_y}{\partial q_1} & \frac{\partial \omega_y}{\partial q_2} & \frac{\partial \omega_y}{\partial q_3}\newline
\frac{\partial \omega_z}{\partial q_0} & \frac{\partial \omega_z}{\partial q_1} & \frac{\partial \omega_z}{\partial q_2} & \frac{\partial \omega_z}{\partial q_3}\newline
\end{bmatrix}
\end{equation}
$$</p><p>So far I haven&rsquo;t explained angular velocity. This I have solved separately, and it&rsquo;s quite simple as long as your robot is serial and doesn&rsquo;t have spherical joints. The partial derivative for the angular velocity w.r.t. each joint is expressed as 1 if that joint rotates along that axis, and 0 if it doesn&rsquo;t. For example, in J₀ (Equation 14), joint q₀ rotates around the x axis, so the partial derivative of $\omega_x$ w.r.t. $q_0$ is 1. In $J_1$ (Equation 15), joint $q_1$ rotates about the z axis, so the partial derivative of $\omega_z$ w.r.t. $q_1$ is 1.</p><p>$$
\begin{equation}
J_0 = Jacobian(com_0) =
\begin{bmatrix}
0 & 0 & 0 & 0\newline
- l_{0} \sin{(q_{0} )} & 0 & 0 & 0\newline
l_{0} \cos{(q_{0} )} & 0 & 0 & 0\newline
1 & 0 & 0 & 0\newline
0 & 0 & 0 & 0\newline
0 & 0 & 0 & 0
\end{bmatrix}
\end{equation}
$$</p><p>I can only show the first two Jacobians here, as the rest are too long to fit on the screen. You&rsquo;ll notice that the Jacobians for the centers of motion of each link ($J_0$, $J_1$, $J_2$, and $J_3$) are calculated as a function of the transformation matrix from the link&rsquo;s base joint to the origin multiplied by that link&rsquo;s center of motion. This confused me the first time around, and I don&rsquo;t want you, the reader, to make the same mistake.</p><p>For example, in the case of $J_1$ (the Jacobian for the second link), the transformation matrix from joint 0 to the world coordinate frame (origin) is multiplied by $com_1$, the center of motion of the link between joints 0 and 1 (the first and second joints, so the second link).</p><p>For $J_0$ (the Jacobian for the first link), no transformation matrix is required because the first joint ($q_0$) is already in the base coordinate system.</p><p>I&rsquo;m probably just confusing you more because my joint indexing starts at zero, but that&rsquo;s for programming purposes and is standard&mldr;</p><p>$$ J_1 = Jacobian(_{org}^0 T com_1) = $$</p><p>$$
\begin{equation}
\begin{bmatrix}
0 & - l_{1} \cos{(q_{1} )} & 0 & 0 \newline
- (L_{0} + l_{1} \cos{(q_{1} )}) \sin{(q_{0} )} & - l_{1} \sin{(q_{1} )} \cos{(q_{0} )} & 0 & 0 \newline
(L_{0} + l_{1} \cos{(q_{1} )}) \cos{(q_{0} )} & - l_{1} \sin{(q_{0} )} \sin{(q_{1} )} & 0 & 0 \newline
1 & 0 & 0 & 0 \newline
0 & 0 & 0 & 0 \newline
0 & 1 & 0 & 0
\end{bmatrix}
\end{equation}
$$</p><p>$$
\begin{equation}
J_2 = Jacobian(_{org}^1 T com_2)
\end{equation}
$$</p><p>$$
\begin{equation}
J_3 = Jacobian(_{org}^2 T com_3)
\end{equation}
$$</p><p>$$
\begin{equation}
J_{EE} = Jacobian(<em>{org}^3 T x</em>{ee})
\end{equation}
$$</p><p>So there you have it. After several headaches, I was able to verify that this setup works in simulation. The chief cause of my problems was that I had solved for the transformation matrices incorrectly! Everything else is easy&ndash;though it looks intimidating, all of the symbolic math can be computationally solved by Matlab/Octave. Just remember, garbage in = garbage out.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbokser.github.io/posts/2020-10-12/><span class=title>« Prev</span><br><span>Model Predictive Control for a Legged Robot</span></a>
<a class=next href=https://bbokser.github.io/posts/2021-07-20/><span class=title>Next »</span><br><span>Stable Bipedal Walking in Simulation</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on twitter" href="https://twitter.com/intent/tweet/?text=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg&url=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f&title=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg&summary=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg&source=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f&title=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on whatsapp" href="https://api.whatsapp.com/send?text=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg%20-%20https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving for the Jacobians of a Robot Leg on telegram" href="https://telegram.me/share/url?text=Solving%20for%20the%20Jacobians%20of%20a%20Robot%20Leg&url=https%3a%2f%2fbbokser.github.io%2fposts%2f2020-05-04%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://bbokser.github.io/>Ben Bokser</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>