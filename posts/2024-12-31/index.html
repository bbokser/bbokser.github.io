<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro to Robot Simulation, Part 2: Contact | Ben Bokser's Blog</title>
<meta name=keywords content="control"><meta name=description content="Okay, so we can simulate a floating point mass subject to arbitrary forces.
Let&rsquo;s now think about what happens when our point mass hits the ground.
Assuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:

Notably, the acceleration at impact approaches infinity, which would be very difficult to simulate&ndash;it would require infinitesimal timesteps.
Of course, in reality there is no such thing as a perfectly stiff and inelastic collision,
but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds."><meta name=author content="Ben Bokser"><link rel=canonical href=https://bbokser.github.io/posts/2024-12-31/><link crossorigin=anonymous href=/assets/css/stylesheet.f5e4015d42de28790ef5dd03b8bc8041968f8b08d6b8a41faded98c8e9953483.css integrity="sha256-9eQBXULeKHkO9d0DuLyAQZaPiwjWuKQfre2YyOmVNIM=" rel="preload stylesheet" as=style><link rel=icon href=https://bbokser.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbokser.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bbokser.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bbokser.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bbokser.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbokser.github.io/posts/2024-12-31/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://bbokser.github.io/posts/2024-12-31/"><meta property="og:site_name" content="Ben Bokser's Blog"><meta property="og:title" content="Intro to Robot Simulation, Part 2: Contact"><meta property="og:description" content="Okay, so we can simulate a floating point mass subject to arbitrary forces. Let’s now think about what happens when our point mass hits the ground.
Assuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:
Notably, the acceleration at impact approaches infinity, which would be very difficult to simulate–it would require infinitesimal timesteps. Of course, in reality there is no such thing as a perfectly stiff and inelastic collision, but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-31T00:00:00+00:00"><meta property="article:tag" content="Control"><meta name=twitter:card content="summary"><meta name=twitter:title content="Intro to Robot Simulation, Part 2: Contact"><meta name=twitter:description content="Okay, so we can simulate a floating point mass subject to arbitrary forces.
Let&rsquo;s now think about what happens when our point mass hits the ground.
Assuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:

Notably, the acceleration at impact approaches infinity, which would be very difficult to simulate&ndash;it would require infinitesimal timesteps.
Of course, in reality there is no such thing as a perfectly stiff and inelastic collision,
but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbokser.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Intro to Robot Simulation, Part 2: Contact","item":"https://bbokser.github.io/posts/2024-12-31/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro to Robot Simulation, Part 2: Contact","name":"Intro to Robot Simulation, Part 2: Contact","description":"Okay, so we can simulate a floating point mass subject to arbitrary forces. Let\u0026rsquo;s now think about what happens when our point mass hits the ground.\nAssuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:\nNotably, the acceleration at impact approaches infinity, which would be very difficult to simulate\u0026ndash;it would require infinitesimal timesteps. Of course, in reality there is no such thing as a perfectly stiff and inelastic collision, but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds.\n","keywords":["control"],"articleBody":"Okay, so we can simulate a floating point mass subject to arbitrary forces. Let’s now think about what happens when our point mass hits the ground.\nAssuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:\nNotably, the acceleration at impact approaches infinity, which would be very difficult to simulate–it would require infinitesimal timesteps. Of course, in reality there is no such thing as a perfectly stiff and inelastic collision, but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds.\nSo how do we do that?\nGeneralizing grossly, there are three overarching categories of methods for simulating contact, which I will cover here.\nThe Hybrid Method In this method, a “guard function” explicitly checks for contact on every timestep. If it is triggered, a “jump map” function is called, which applies impact discontinuities. Additionally, separate dynamics models can be used depending on whether or not the object is currently in contact.\nLet’s look at a code example. We will use the same state-space system from Part 1, a vertically constrained point mass.\nimport numpy as np import plotting n_x = 2 # length of state vector n_u = 1 # length of control vector m = 10 # mass of the rocket in kg A = np.array([[0, 1], [0, 0]]) B = np.array([[0], [1 / m]]) G = np.array([[0], [-9.81]]) dt = 0.001 # timestep size def dynamics_ct(X, U): dX = A @ X + B @ U + G.flatten() return dX def integrator_euler(dyn_ct, xk, uk): X_next = xk + dt * dyn_ct(xk, uk) return X_next Next, we define our “jump map”. This function will be called whenever the object passes through the ground. It rewrites the position to avoid interpenetration. In addition, it rewrites the velocity based on a chosen coefficient of restitution $e$ and calculates the ground reaction force necessary for this to occur. Here we have set $e$ to 0.7 arbitrarily.\ne = 0.7 # coefficient of restitution def jump_map(X): # X[0] = 0 # reset z position to zero v_before = X[1] # velocity before impact v_after = ( -e * v_before ) # reverse velocity and multiply by coefficient of restitution a = (v_after - v_before) / dt # acceleration F = m * a # get ground reaction force X[1] = v_after # velocity after impact return X, F Finally, we iterate through the timesteps. The jump map is called whenever the object’s position value is negative.\nN = 1000 # number of timesteps X_hist = np.zeros((N, n_x)) # array of state vectors for each timestep F_hist = np.zeros((N, 1)) # array of state vectors for each timestep X_hist[0, :] = np.array([[1, 0]]) # start from a height of 1 m U_hist = np.zeros((N - 1, n_u)) # array of control vectors for each timestep for k in range(N - 1): if X_hist[k, 0] \u003c 0: # guard function X_hist[k, :], F_hist[k, :] = jump_map( X_hist[k, :] ) # dynamics rewrite based on impact X_hist[k + 1, :] = integrator_euler(dynamics_ct, X_hist[k, :], U_hist[k, :]) Click here for the full code.\nLet’s look at the results: Everything here seems reasonable, except that the ball is probably unrealistically stiff for how bouncy it is. If we set $e = 0$, though, we do see an issue:\nThe ball is rapidly switching between being in and out of contact when it should just be sitting there. With the hybrid method, you really need an additional dynamics function for the contact state. Then, you need to worry about how to exit contact… but I won’t get into that here.\nSmooth Contact In this method, contact is approximated as a spring-damper system. The trick here is that the spring-damper model is used at all times, regardless of whether or not contact should be occurring.\nLet’s look at the code.\nThe function below takes as inputs the distance of the object from the ground and its speed. It then calculates the ground reaction force based on user-tuned spring and damping constants.\ndef get_grf(X: np.ndarray) -\u003e float: z = X[0] dz = X[1] k = 0.01 # spring constant b = 0.1 # damping constant amp = 1500 # desired max force c = amp * 0.5 / k distance_fn = -c * np.tanh(z * 100) + c F_spring = k * distance_fn F_damper = -b * dz * distance_fn grf = F_spring + F_damper return grf If we plot this function, we see that the force drops off precipitously as distance from the ground increases.\nI chose a $\\tanh$ relationship between input and output somewhat arbitrarily to achieve this effect. As a consequence there is a max ground reaction force possible, which isn’t great. But you can tune it.\nLet’s look at the rest of the code now. The dynamics and integrator are exactly the same as in the hybrid example.\nBut the simulation is simpler. There’s no explicit check for interpenetration; the spring-damper function is simply called on every timestep. When the object isn’t close to the ground, the forces are just too small to notice. This is what makes the smooth contact method both beautifully elegant, and just wrong.\nn_x = 2 # length of state vector n_u = 1 # length of control vector m = 10 # mass of the rocket in kg A = np.array([[0, 1], [0, 0]]) B = np.array([[0], [1 / m]]) G = np.array([[0], [-9.81]]) dt = 0.001 # timestep size def dynamics_ct(X, U): dX = A @ X + B @ U + G.flatten() return dX def integrator_euler(dyn_ct, xk, uk): X_next = xk + dt * dyn_ct(xk, uk) return X_next N = 1000 # number of timesteps X_hist = np.zeros((N, n_x)) # array of state vectors for each timestep F_hist = np.zeros((N, n_u)) # array of state vectors for each timestep X_hist[0, :] = np.array([[1, 0]]) for k in range(N - 1): F_hist[k, :] = get_grf(X_hist[k, :]) # get spring-damper force X_hist[k + 1, :] = integrator_euler(dynamics_ct, X_hist[k, :], F_hist[k, :]) Click here for the full code.\nNote that I’m feeding the ground reaction force in to where the control vector is supposed to go. Since both the control and GRF can apply a vertical force, this is a little cheat to let me write less lines of code.\nLet’s look at the results. Pretty good!\nTime-Stepping In this method, an optimization problem is solved on each timestep to compute the contact forces required to satisfy interpenetration constraints.\nIdeally, the system is described by the following four constraints. The first is our discrete-time system dynamics. Here, $X_k$ and $U_k$ are inputs and we want to solve for $X_{k+1}$ and $f_k$, where $f_k$ represents the reaction force between the ground and the point mass. Out of a convenient contrivance, $f_k$ uses the same input matrix $B_d$ as the control input $U_k$.\n$$ \\begin{equation} X_{k+1} = A_dX_k + B_dU_k + B_df_k + G_d = 0 \\end{equation} $$\nSecondly, we have our interpenetration constraint. This just says that the point mass must stay above the ground. As a reminder, $z_{k+1}$ is an element of $X_{k+1}$. $$ \\begin{equation} z_{k+1} \\geq 0 \\end{equation} $$\nThirdly, we constrain the ground reaction force to be positive only. If it were negative, the ground would be pulling on the mass.\n$$ \\begin{equation} f_k \\geq 0 \\end{equation} $$\nAnd finally, we have what is known as the complementarity constraint. This is a pretty neat trick. In order for the constraint to be satisfied, either $f_k$ or $z_{k+1}$ must be equal to zero at any given timestep. Therefore, when the object is not touching the ground, $f_k$ must be zero.\n$$ \\begin{equation} f_k z_{k+1} = 0 \\end{equation} $$\nThe Optimization Problem To practically implement this in an easy and accessible way, we will be using the IPOPT solver, which is broadly available. Bear in mind that you really need to write a custom solver to do this properly. But to make this solvable with IPOPT, we have to add a slack variable, denoted by $s$, to “relax” the discrete switching behavior of the complementarity constraint.\nThe optimization problem is as shown below. We attempt to minimize $s^2$ in the objective function, as opposed to just $s$, because it penalizes larger values more severely.\n$$ \\begin{align} \\min_{X_{k+1}, f_k, s_k} \\quad \u0026 s_k^2 \\\\ \\textrm{s.t.} \\quad \u0026 A_dX_k + B_dU_k + B_df_k + G_d - X_{k+1} = 0 \\\\ \u0026 s_k - f_k z_{k+1} \\geq 0 \\\\ \u0026 z_{k+1} \\geq 0 \\\\ \u0026 f_k \\geq 0 \\\\ \u0026 s_k \\geq 0 \\\\ \\end{align} $$ The Code Starting with standard setup stuff, except that we are going to use the semi-implicit Euler method, which performs better here than other integrators. The only difference between it and the regular Euler method is that it uses the velocity term from the next ($k+1$) timestep.\nimport numpy as np import plotting import casadi as cs n_a = 2 # length of state vector n_u = 1 # length of control vector m = 10 # mass of the rocket in kg g = 9.81 # gravitational constant A = np.array([[0, 1], [0, 0]]) B = np.array([[0], [1 / m]]) G = np.array([[0], [-g]]) dt = 0.001 # timestep size def dynamics_ct(X, U): dX = A @ X + B @ U + G.flatten() return dX def integrator_euler_semi_implicit(dyn_ct, xk, uk, xk1): xk_semi = cs.SX.zeros(n_a) xk_semi[0] = xk[0] xk_semi[1] = xk1[1] X_next = xk + dt * dyn_ct(xk_semi, uk) return X_next X_0 = np.array([1, 0]) N = 1000 X_hist = np.zeros((N, n_a)) # array of state vectors for each timestep F_hist = np.zeros(N) # array of z GRF forces for each timestep s_hist = np.zeros(N) # array of slack var values for each timestep X_hist[0, :] = X_0 U_hist = np.zeros((N - 1, n_u)) # array of control vectors for each timestep Here is where we define the optimization problem. We are using CaSaDi, a library for numerical optimization that has IPOPT built-in.\n# initialize casadi variables Xk1 = cs.SX.sym(\"Xk1\", n_a) # X(k+1), state at next timestep F = cs.SX.sym(\"F\", n_u) # force s = cs.SX.sym(\"s\", 1) # slack variable X = cs.SX.sym(\"X\", n_a) # state U = cs.SX.sym(\"U\", n_u) # controls zk1 = Xk1[0] # vert pos dzk1 = Xk1[1] # vertical vel obj = s**2 constr = [] # init constraints # dynamics constr = cs.vertcat( constr, cs.SX(integrator_euler_semi_implicit(dynamics_ct, X, U + F, Xk1) - Xk1) ) # relaxed complementarity constr = cs.vertcat(constr, cs.SX(s - F * zk1)) opt_variables = cs.vertcat(Xk1, F, s) # parameters = X parameters = cs.vertcat(X, U) lcp = {\"x\": opt_variables, \"p\": parameters, \"f\": obj, \"g\": constr} opts = { \"print_time\": 0, \"ipopt.print_level\": 0, \"ipopt.tol\": 1e-6, \"ipopt.max_iter\": 500, } solver = cs.nlpsol(\"S\", \"ipopt\", lcp, opts) You may have noticed that constraints (8), (9), and (10) aren’t shown above. That’s because they can be defined as variable bounds:\nn_var = np.shape(opt_variables)[0] n_par = np.shape(parameters)[0] n_g = np.shape(constr)[0] # variable bounds ubx = [1e10] * n_var lbx = [-1e10] * n_var lbx[0] = 0 # set z positive only lbx[n_a] = 0 # set F positive only lbx[-1] = 0 # set slack variable \u003e= 0 Next we define the numerical values of the constraint bounds.\n# constraint bounds ubg = [0] * n_g ubg[-1] = 1e10 # set relaxed complementarity \u003e= 0 lbg = [0] * n_g And finally, we run the sim. As previously noted, $X_k$ and $U_k$ are input parameters to the solver and the value of $X_k$ is taken from the previous timestep.\n# run the sim p_values = np.zeros(n_par) x0_values = np.zeros(n_var) for k in range(N - 1): print(\"timestep = \", k) p_values[:n_a] = X_hist[k, :] p_values[n_a:] = U_hist[k, :] x0_values[:n_a] = X_hist[k, :] sol = solver(lbx=lbx, ubx=ubx, lbg=lbg, ubg=ubg, p=p_values, x0=x0_values) X_hist[k + 1, :] = np.reshape(sol[\"x\"][0:n_a], (-1,)) F_hist[k] = sol[\"x\"][n_a] s_hist[k] = sol[\"x\"][n_a + n_u] pos_hist = X_hist[:, 0] vel_hist = X_hist[:, 1] Click here for the full code.\nHere’s the result.\nConclusion Here’s a comparison of the three presented methods.\nMethod Pros Cons Hybrid Accurate Does not scale well with increasing points of contact, difficulty with simultaneous impacts, not differentiable Smooth Simple, multiple and simultaneous contact, differentiable Low accuracy Time-Stepping Accurate, multiple and simultaneous contact Difficult implementation, very computationally expensive, not differentiable In the next post in this series, I’ll add friction into the mix, so stay tuned. Also, check out Zac Manchester’s class on robot dynamics, which I ripped off pretty heavily for this post.\n","wordCount":"2075","inLanguage":"en","datePublished":"2024-12-31T00:00:00Z","dateModified":"2024-12-31T00:00:00Z","author":{"@type":"Person","name":"Ben Bokser"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbokser.github.io/posts/2024-12-31/"},"publisher":{"@type":"Organization","name":"Ben Bokser's Blog","logo":{"@type":"ImageObject","url":"https://bbokser.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbokser.github.io/ accesskey=h title="Ben Bokser (Alt + H)">Ben Bokser</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbokser.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://bbokser.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bbokser.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://benbokser.com/ title=Portfolio><span>Portfolio</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbokser.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbokser.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Intro to Robot Simulation, Part 2: Contact</h1><div class=post-meta><span title='2024-12-31 00:00:00 +0000 UTC'>December 31, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Ben Bokser&nbsp;|&nbsp;<a href=https://github.com/bbokser/bbokser.github.io/tree/main/content/posts/2024-12-31.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-hybrid-method aria-label="The Hybrid Method">The Hybrid Method</a></li><li><a href=#smooth-contact aria-label="Smooth Contact">Smooth Contact</a></li><li><a href=#time-stepping aria-label=Time-Stepping>Time-Stepping</a><ul><ul><li><a href=#the-optimization-problem aria-label="The Optimization Problem">The Optimization Problem</a></li><li><a href=#the-code aria-label="The Code">The Code</a></li></ul></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>Okay, so we can simulate a floating point mass subject to arbitrary forces.
Let&rsquo;s now think about what happens when our point mass hits the ground.</p><p>Assuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:</p><p><img loading=lazy src=/images/2024-12-31/impact.png></p><p>Notably, the acceleration at impact approaches infinity, which would be very difficult to simulate&ndash;it would require infinitesimal timesteps.
Of course, in reality there is no such thing as a perfectly stiff and inelastic collision,
but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds.</p><p>So how do we do that?</p><p>Generalizing grossly, there are three overarching categories of methods for simulating contact, which I will cover here.</p><h1 id=the-hybrid-method>The Hybrid Method<a hidden class=anchor aria-hidden=true href=#the-hybrid-method>#</a></h1><p>In this method, a &ldquo;guard function&rdquo; explicitly checks for contact on every timestep.
If it is triggered, a &ldquo;jump map&rdquo; function is called, which applies impact discontinuities.
Additionally, separate dynamics models can be used depending on whether or not the object is currently in contact.</p><p>Let&rsquo;s look at a code example. We will use the same state-space system from Part 1, a vertically constrained point mass.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> plotting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># length of state vector</span>
</span></span><span style=display:flex><span>n_u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># length of control vector</span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># mass of the rocket in kg</span>
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> m]])
</span></span><span style=display:flex><span>G <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>9.81</span>]])
</span></span><span style=display:flex><span>dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>  <span style=color:#75715e># timestep size</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_ct</span>(X, U):
</span></span><span style=display:flex><span>    dX <span style=color:#f92672>=</span> A <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> B <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> G<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_euler</span>(dyn_ct, xk, uk):
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> dyn_ct(xk, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span></code></pre></div><p>Next, we define our &ldquo;jump map&rdquo;. This function will be called whenever the object passes through the ground. It rewrites the position to avoid interpenetration. In addition, it rewrites the velocity based on a chosen <a href=https://en.wikipedia.org/wiki/Coefficient_of_restitution>coefficient of restitution</a> $e$ and calculates the ground reaction force necessary for this to occur. Here we have set $e$ to 0.7 arbitrarily.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>e <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.7</span>  <span style=color:#75715e># coefficient of restitution</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>jump_map</span>(X):  <span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>    X[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># reset z position to zero</span>
</span></span><span style=display:flex><span>    v_before <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>1</span>]  <span style=color:#75715e># velocity before impact</span>
</span></span><span style=display:flex><span>    v_after <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span>e <span style=color:#f92672>*</span> v_before
</span></span><span style=display:flex><span>    )  <span style=color:#75715e># reverse velocity and multiply by coefficient of restitution</span>
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> (v_after <span style=color:#f92672>-</span> v_before) <span style=color:#f92672>/</span> dt  <span style=color:#75715e># acceleration</span>
</span></span><span style=display:flex><span>    F <span style=color:#f92672>=</span> m <span style=color:#f92672>*</span> a  <span style=color:#75715e># get ground reaction force</span>
</span></span><span style=display:flex><span>    X[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> v_after  <span style=color:#75715e># velocity after impact</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X, F
</span></span></code></pre></div><p>Finally, we iterate through the timesteps. The jump map is called whenever the object&rsquo;s position value is negative.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># number of timesteps</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_x))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>F_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, <span style=color:#ae81ff>1</span>))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])  <span style=color:#75715e># start from a height of 1 m</span>
</span></span><span style=display:flex><span>U_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, n_u))  <span style=color:#75715e># array of control vectors for each timestep</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> X_hist[k, <span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># guard function</span>
</span></span><span style=display:flex><span>        X_hist[k, :], F_hist[k, :] <span style=color:#f92672>=</span> jump_map(
</span></span><span style=display:flex><span>            X_hist[k, :]
</span></span><span style=display:flex><span>        )  <span style=color:#75715e># dynamics rewrite based on impact</span>
</span></span><span style=display:flex><span>    X_hist[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> integrator_euler(dynamics_ct, X_hist[k, :], U_hist[k, :])
</span></span></code></pre></div><p>Click <a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_1d_con_hybrid.py>here</a> for the full code.</p><p>Let&rsquo;s look at the results:
<img loading=lazy src=/images/2024-12-31/1d_con_hybrid_e0.7.gif#center>
<img loading=lazy src=/images/2024-12-31/1d_con_hybrid_e0.7.png></p><p>Everything here seems reasonable, except that the ball is probably unrealistically stiff for how bouncy it is. If we set $e = 0$, though, we do see an issue:</p><p><img loading=lazy src=/images/2024-12-31/1d_con_hybrid.png></p><p>The ball is rapidly switching between being in and out of contact when it should just be sitting there. With the hybrid method, you really need an additional dynamics function for the contact state. Then, you need to worry about how to <em>exit</em> contact&mldr; but I won&rsquo;t get into that here.</p><h1 id=smooth-contact>Smooth Contact<a hidden class=anchor aria-hidden=true href=#smooth-contact>#</a></h1><p>In this method, contact is approximated as a spring-damper system.
The trick here is that the spring-damper model is used at all times,
regardless of whether or not contact should be occurring.</p><p>Let&rsquo;s look at the code.</p><p>The function below takes as inputs the distance of the object from the ground and its speed. It then calculates the ground reaction force based on user-tuned spring and damping constants.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_grf</span>(X: np<span style=color:#f92672>.</span>ndarray) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    dz <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>  <span style=color:#75715e># spring constant</span>
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>  <span style=color:#75715e># damping constant</span>
</span></span><span style=display:flex><span>    amp <span style=color:#f92672>=</span> <span style=color:#ae81ff>1500</span>  <span style=color:#75715e># desired max force</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> amp <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>/</span> k
</span></span><span style=display:flex><span>    distance_fn <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>c <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>tanh(z <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span>) <span style=color:#f92672>+</span> c
</span></span><span style=display:flex><span>    F_spring <span style=color:#f92672>=</span> k <span style=color:#f92672>*</span> distance_fn
</span></span><span style=display:flex><span>    F_damper <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>b <span style=color:#f92672>*</span> dz <span style=color:#f92672>*</span> distance_fn
</span></span><span style=display:flex><span>    grf <span style=color:#f92672>=</span> F_spring <span style=color:#f92672>+</span> F_damper
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> grf
</span></span></code></pre></div><p>If we plot this function, we see that the force drops off precipitously as distance from the ground increases.</p><p><img loading=lazy src=/images/2024-12-31/grf_vs_phi.png></p><p>I chose a $\tanh$ relationship between input and output somewhat arbitrarily to achieve this effect. As a consequence there is a max ground reaction force possible, which isn&rsquo;t great. But you can tune it.</p><p>Let&rsquo;s look at the rest of the code now. The dynamics and integrator are exactly the same as in the hybrid example.</p><p>But the simulation is simpler. There&rsquo;s no explicit check for interpenetration; the spring-damper function is simply called on every timestep. When the object isn&rsquo;t close to the ground, the forces are just too small to notice. This is what makes the smooth contact method both beautifully elegant, and just wrong.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>n_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># length of state vector</span>
</span></span><span style=display:flex><span>n_u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># length of control vector</span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># mass of the rocket in kg</span>
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> m]])
</span></span><span style=display:flex><span>G <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>9.81</span>]])
</span></span><span style=display:flex><span>dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>  <span style=color:#75715e># timestep size</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_ct</span>(X, U):
</span></span><span style=display:flex><span>    dX <span style=color:#f92672>=</span> A <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> B <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> G<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_euler</span>(dyn_ct, xk, uk):
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> dyn_ct(xk, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># number of timesteps</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_x))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>F_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_u))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    F_hist[k, :] <span style=color:#f92672>=</span> get_grf(X_hist[k, :])  <span style=color:#75715e># get spring-damper force</span>
</span></span><span style=display:flex><span>    X_hist[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> integrator_euler(dynamics_ct, X_hist[k, :], F_hist[k, :])
</span></span></code></pre></div><p>Click <a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_1d_con_smooth.py>here</a> for the full code.</p><p>Note that I&rsquo;m feeding the ground reaction force in to where the control vector is supposed to go. Since both the control and GRF can apply a vertical force, this is a little cheat to let me write less lines of code.</p><p>Let&rsquo;s look at the results. Pretty good!</p><p><img loading=lazy src=/images/2024-12-31/1d_con_smooth.gif#center>
<img loading=lazy src=/images/2024-12-31/1d_con_smooth.png></p><h1 id=time-stepping>Time-Stepping<a hidden class=anchor aria-hidden=true href=#time-stepping>#</a></h1><p>In this method, an optimization problem is solved on each timestep to compute the contact forces required to satisfy interpenetration constraints.</p><p>Ideally, the system is described by the following four constraints. The first is our discrete-time system dynamics. Here, $X_k$ and $U_k$ are inputs and we want to solve for $X_{k+1}$ and $f_k$, where $f_k$ represents the reaction force between the ground and the point mass. Out of a convenient contrivance, $f_k$ uses the same input matrix $B_d$ as the control input $U_k$.</p><p>$$
\begin{equation}
X_{k+1} = A_dX_k + B_dU_k + B_df_k + G_d = 0
\end{equation}
$$</p><p>Secondly, we have our interpenetration constraint. This just says that the point mass must stay above the ground. As a reminder, $z_{k+1}$ is an element of $X_{k+1}$.
$$
\begin{equation}
z_{k+1} \geq 0
\end{equation}
$$</p><p>Thirdly, we constrain the ground reaction force to be positive only. If it were negative, the ground would be pulling on the mass.</p><p>$$
\begin{equation}
f_k \geq 0
\end{equation}
$$</p><p>And finally, we have what is known as the complementarity constraint. This is a pretty neat trick. In order for the constraint to be satisfied, either $f_k$ or $z_{k+1}$ must be equal to zero at any given timestep. Therefore, when the object is not touching the ground, $f_k$ must be zero.</p><p>$$
\begin{equation}
f_k z_{k+1} = 0
\end{equation}
$$</p><h3 id=the-optimization-problem>The Optimization Problem<a hidden class=anchor aria-hidden=true href=#the-optimization-problem>#</a></h3><p>To practically implement this in an easy and accessible way, we will be using the <a href=https://en.wikipedia.org/wiki/IPOPT>IPOPT</a> solver, which is broadly available. Bear in mind that you really need to write a custom solver to do this properly. But to make this solvable with IPOPT, we have to add a slack variable, denoted by $s$, to &ldquo;relax&rdquo; the discrete switching behavior of the complementarity constraint.</p><p>The optimization problem is as shown below. We attempt to minimize $s^2$ in the objective function, as opposed to just $s$, because it penalizes larger values more severely.</p>$$
\begin{align}
\min_{X_{k+1}, f_k, s_k} \quad & s_k^2 \\
\textrm{s.t.} \quad
& A_dX_k + B_dU_k + B_df_k + G_d - X_{k+1} = 0 \\
& s_k - f_k z_{k+1} \geq 0 \\
& z_{k+1} \geq 0 \\
& f_k \geq 0 \\
& s_k \geq 0 \\
\end{align}
$$<h3 id=the-code>The Code<a hidden class=anchor aria-hidden=true href=#the-code>#</a></h3><p>Starting with standard setup stuff, except that we are going to use the <a href=https://en.wikipedia.org/wiki/Semi-implicit_Euler_method>semi-implicit Euler method</a>, which performs better here than other integrators. The only difference between it and the regular Euler method is that it uses the velocity term from the next ($k+1$) timestep.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> plotting
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> casadi <span style=color:#66d9ef>as</span> cs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># length of state vector</span>
</span></span><span style=display:flex><span>n_u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># length of control vector</span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># mass of the rocket in kg</span>
</span></span><span style=display:flex><span>g <span style=color:#f92672>=</span> <span style=color:#ae81ff>9.81</span>  <span style=color:#75715e># gravitational constant</span>
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> m]])
</span></span><span style=display:flex><span>G <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span>g]])
</span></span><span style=display:flex><span>dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>  <span style=color:#75715e># timestep size</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_ct</span>(X, U):
</span></span><span style=display:flex><span>    dX <span style=color:#f92672>=</span> A <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> B <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> G<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_euler_semi_implicit</span>(dyn_ct, xk, uk, xk1):
</span></span><span style=display:flex><span>    xk_semi <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>zeros(n_a)
</span></span><span style=display:flex><span>    xk_semi[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> xk[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    xk_semi[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> xk1[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> dyn_ct(xk_semi, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>X_0 <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_a))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>F_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)  <span style=color:#75715e># array of z GRF forces for each timestep</span>
</span></span><span style=display:flex><span>s_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)  <span style=color:#75715e># array of slack var values for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> X_0
</span></span><span style=display:flex><span>U_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, n_u))  <span style=color:#75715e># array of control vectors for each timestep</span>
</span></span></code></pre></div><p>Here is where we define the optimization problem. We are using <a href=https://web.casadi.org/docs/>CaSaDi</a>, a library for numerical optimization that has IPOPT built-in.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># initialize casadi variables</span>
</span></span><span style=display:flex><span>Xk1 <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;Xk1&#34;</span>, n_a)  <span style=color:#75715e># X(k+1), state at next timestep</span>
</span></span><span style=display:flex><span>F <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;F&#34;</span>, n_u)  <span style=color:#75715e># force</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;s&#34;</span>, <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># slack variable</span>
</span></span><span style=display:flex><span>X <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;X&#34;</span>, n_a)  <span style=color:#75715e># state</span>
</span></span><span style=display:flex><span>U <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;U&#34;</span>, n_u)  <span style=color:#75715e># controls</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>zk1 <span style=color:#f92672>=</span> Xk1[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e># vert pos</span>
</span></span><span style=display:flex><span>dzk1 <span style=color:#f92672>=</span> Xk1[<span style=color:#ae81ff>1</span>]  <span style=color:#75715e># vertical vel</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> s<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> []  <span style=color:#75715e># init constraints</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dynamics</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(
</span></span><span style=display:flex><span>    constr, cs<span style=color:#f92672>.</span>SX(integrator_euler_semi_implicit(dynamics_ct, X, U <span style=color:#f92672>+</span> F, Xk1) <span style=color:#f92672>-</span> Xk1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># relaxed complementarity</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(constr, cs<span style=color:#f92672>.</span>SX(s <span style=color:#f92672>-</span> F <span style=color:#f92672>*</span> zk1))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>opt_variables <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(Xk1, F, s)
</span></span><span style=display:flex><span><span style=color:#75715e># parameters = X</span>
</span></span><span style=display:flex><span>parameters <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(X, U)
</span></span><span style=display:flex><span>lcp <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;x&#34;</span>: opt_variables, <span style=color:#e6db74>&#34;p&#34;</span>: parameters, <span style=color:#e6db74>&#34;f&#34;</span>: obj, <span style=color:#e6db74>&#34;g&#34;</span>: constr}
</span></span><span style=display:flex><span>opts <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;print_time&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.print_level&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.tol&#34;</span>: <span style=color:#ae81ff>1e-6</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.max_iter&#34;</span>: <span style=color:#ae81ff>500</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>solver <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>nlpsol(<span style=color:#e6db74>&#34;S&#34;</span>, <span style=color:#e6db74>&#34;ipopt&#34;</span>, lcp, opts)
</span></span></code></pre></div><p>You may have noticed that constraints (8), (9), and (10) aren&rsquo;t shown above. That&rsquo;s because they can be defined as variable bounds:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>n_var <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(opt_variables)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>n_par <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(parameters)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>n_g <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(constr)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># variable bounds</span>
</span></span><span style=display:flex><span>ubx <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1e10</span>] <span style=color:#f92672>*</span> n_var
</span></span><span style=display:flex><span>lbx <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1e10</span>] <span style=color:#f92672>*</span> n_var
</span></span><span style=display:flex><span>lbx[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># set z positive only</span>
</span></span><span style=display:flex><span>lbx[n_a] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># set F positive only</span>
</span></span><span style=display:flex><span>lbx[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># set slack variable &gt;= 0</span>
</span></span></code></pre></div><p>Next we define the numerical values of the constraint bounds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># constraint bounds</span>
</span></span><span style=display:flex><span>ubg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n_g
</span></span><span style=display:flex><span>ubg[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e10</span>  <span style=color:#75715e># set relaxed complementarity &gt;= 0</span>
</span></span><span style=display:flex><span>lbg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n_g
</span></span></code></pre></div><p>And finally, we run the sim. As previously noted, $X_k$ and $U_k$ are input parameters to the solver and the value of $X_k$ is taken from the previous timestep.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># run the sim</span>
</span></span><span style=display:flex><span>p_values <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(n_par)
</span></span><span style=display:flex><span>x0_values <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(n_var)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;timestep = &#34;</span>, k)
</span></span><span style=display:flex><span>    p_values[:n_a] <span style=color:#f92672>=</span> X_hist[k, :]
</span></span><span style=display:flex><span>    p_values[n_a:] <span style=color:#f92672>=</span> U_hist[k, :]
</span></span><span style=display:flex><span>    x0_values[:n_a] <span style=color:#f92672>=</span> X_hist[k, :]
</span></span><span style=display:flex><span>    sol <span style=color:#f92672>=</span> solver(lbx<span style=color:#f92672>=</span>lbx, ubx<span style=color:#f92672>=</span>ubx, lbg<span style=color:#f92672>=</span>lbg, ubg<span style=color:#f92672>=</span>ubg, p<span style=color:#f92672>=</span>p_values, x0<span style=color:#f92672>=</span>x0_values)
</span></span><span style=display:flex><span>    X_hist[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>reshape(sol[<span style=color:#e6db74>&#34;x&#34;</span>][<span style=color:#ae81ff>0</span>:n_a], (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,))
</span></span><span style=display:flex><span>    F_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a]
</span></span><span style=display:flex><span>    s_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a <span style=color:#f92672>+</span> n_u]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pos_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>vel_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><p>Click <a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_1d_con_tstep.py>here</a> for the full code.</p><p>Here&rsquo;s the result.</p><p><img loading=lazy src=/images/2024-12-31/1d_con_tstep.gif#center>
<img loading=lazy src=/images/2024-12-31/1d_con_tstep.png></p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Here&rsquo;s a comparison of the three presented methods.</p><table><thead><tr><th>Method</th><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>Hybrid</td><td>Accurate</td><td>Does not scale well with increasing points of contact, difficulty with simultaneous impacts, not differentiable</td></tr><tr><td>Smooth</td><td>Simple, multiple and simultaneous contact, differentiable</td><td>Low accuracy</td></tr><tr><td>Time-Stepping</td><td>Accurate, multiple and simultaneous contact</td><td>Difficult implementation, very computationally expensive, not differentiable</td></tr></tbody></table><p>In the next post in this series, I&rsquo;ll add friction into the mix, so stay tuned. Also, check out Zac Manchester&rsquo;s class on robot dynamics, which I <a href="https://youtu.be/iTBLkLKO948?feature=shared">ripped off pretty heavily for this post</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bbokser.github.io/tags/control/>Control</a></li></ul><nav class=paginav><a class=next href=https://bbokser.github.io/posts/2024-06-12/><span class=title>Next »</span><br><span>Reviving an MP3 Player from 2007</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on x" href="https://x.com/intent/tweet/?text=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f&amp;hashtags=control"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f&amp;title=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact&amp;summary=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact&amp;source=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f&title=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on whatsapp" href="https://api.whatsapp.com/send?text=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact%20-%20https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on telegram" href="https://telegram.me/share/url?text=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 2: Contact on ycombinator" href="https://news.ycombinator.com/submitlink?t=Intro%20to%20Robot%20Simulation%2c%20Part%202%3a%20Contact&u=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-12-31%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div class=giscus><script>function getGiscusTheme(){const e=localStorage.getItem("pref-theme"),t=e==null||e=="light"?"light":"dark";return t}function setGiscusTheme(){function e(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}e({setConfig:{theme:getGiscusTheme()=="light"?"dark":"light"}})}const attrs={src:"https://giscus.app/client.js","data-repo":"bbokser/bbokser.github.io","data-repo-id":"R_kgDOGxN6Pg","data-category":"Announcements","data-category-id":"DIC_kwDOIWVKbs4CSTz_","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getGiscusTheme(),"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(attrs).forEach(([e,t])=>giscusScript.setAttribute(e,t)),document.body.appendChild(giscusScript);const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",setGiscusTheme)</script><noscript>Please enable JavaScript to view the comments</noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://bbokser.github.io/>Ben Bokser's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>