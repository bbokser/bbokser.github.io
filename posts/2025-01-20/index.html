<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro to Robot Simulation, Part 3: Friction | Ben Bokser's Blog</title>
<meta name=keywords content="control"><meta name=description content="In this post, we will add 1-dimensional coulomb friction to our simulation.
First off, we&rsquo;re going to need to allow movement in the horizontal direction.
Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.
 
$$
\begin{equation}
\underbrace{\begin{bmatrix} \dot{x} \\ \dot{z} \\ \ddot{x} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} = 
\underbrace{\begin{bmatrix}
	0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \\
\end{bmatrix}}_A
\underbrace{\begin{bmatrix}
    x \\
    z \\
    \dot{x} \\ 
    \dot{z} 
\end{bmatrix}}_X 
+ \underbrace{\begin{bmatrix} 
    0 & 0 \\
    0 & 0 \\ 
    \frac{1}{m} & 0 \\
    0 & \frac{1}{m}
\end{bmatrix}}_B 
\underbrace{\begin{bmatrix}
    f_x \\
    f_z
\end{bmatrix}}_F 
+ \underbrace{\begin{bmatrix} 
    0 \\
    0 \\
    0 \\
    -9.81 
\end{bmatrix}}_G
\end{equation}
$$
Modeling Friction
For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation."><meta name=author content="Ben Bokser"><link rel=canonical href=https://bbokser.github.io/posts/2025-01-20/><link crossorigin=anonymous href=/assets/css/stylesheet.6630e5432f5016f2fa45cc7f66feb6089deb79d4cb7c3ee5c9876b6370c9e6a7.css integrity="sha256-ZjDlQy9QFvL6Rcx/Zv62CJ3redTLfD7lyYdrY3DJ5qc=" rel="preload stylesheet" as=style><link rel=icon href=https://bbokser.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbokser.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bbokser.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bbokser.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bbokser.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbokser.github.io/posts/2025-01-20/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://bbokser.github.io/posts/2025-01-20/"><meta property="og:site_name" content="Ben Bokser's Blog"><meta property="og:title" content="Intro to Robot Simulation, Part 3: Friction"><meta property="og:description" content="In this post, we will add 1-dimensional coulomb friction to our simulation.
First off, we’re going to need to allow movement in the horizontal direction. Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.
$$ \begin{equation} \underbrace{\begin{bmatrix} \dot{x} \\ \dot{z} \\ \ddot{x} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} = \underbrace{\begin{bmatrix} 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ \end{bmatrix}}_A \underbrace{\begin{bmatrix} x \\ z \\ \dot{x} \\ \dot{z} \end{bmatrix}}_X + \underbrace{\begin{bmatrix} 0 & 0 \\ 0 & 0 \\ \frac{1}{m} & 0 \\ 0 & \frac{1}{m} \end{bmatrix}}_B \underbrace{\begin{bmatrix} f_x \\ f_z \end{bmatrix}}_F + \underbrace{\begin{bmatrix} 0 \\ 0 \\ 0 \\ -9.81 \end{bmatrix}}_G \end{equation} $$ Modeling Friction For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-20T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-20T00:00:00+00:00"><meta property="article:tag" content="Control"><meta name=twitter:card content="summary"><meta name=twitter:title content="Intro to Robot Simulation, Part 3: Friction"><meta name=twitter:description content="In this post, we will add 1-dimensional coulomb friction to our simulation.
First off, we&rsquo;re going to need to allow movement in the horizontal direction.
Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.
 
$$
\begin{equation}
\underbrace{\begin{bmatrix} \dot{x} \\ \dot{z} \\ \ddot{x} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} = 
\underbrace{\begin{bmatrix}
	0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \\
\end{bmatrix}}_A
\underbrace{\begin{bmatrix}
    x \\
    z \\
    \dot{x} \\ 
    \dot{z} 
\end{bmatrix}}_X 
+ \underbrace{\begin{bmatrix} 
    0 & 0 \\
    0 & 0 \\ 
    \frac{1}{m} & 0 \\
    0 & \frac{1}{m}
\end{bmatrix}}_B 
\underbrace{\begin{bmatrix}
    f_x \\
    f_z
\end{bmatrix}}_F 
+ \underbrace{\begin{bmatrix} 
    0 \\
    0 \\
    0 \\
    -9.81 
\end{bmatrix}}_G
\end{equation}
$$
Modeling Friction
For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbokser.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Intro to Robot Simulation, Part 3: Friction","item":"https://bbokser.github.io/posts/2025-01-20/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro to Robot Simulation, Part 3: Friction","name":"Intro to Robot Simulation, Part 3: Friction","description":"In this post, we will add 1-dimensional coulomb friction to our simulation.\nFirst off, we\u0026rsquo;re going to need to allow movement in the horizontal direction. Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.\n$$ \\begin{equation} \\underbrace{\\begin{bmatrix} \\dot{x} \\\\ \\dot{z} \\\\ \\ddot{x} \\\\ \\ddot{z} \\end{bmatrix}}_{\\dot{X}} = \\underbrace{\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix}}_A \\underbrace{\\begin{bmatrix} x \\\\ z \\\\ \\dot{x} \\\\ \\dot{z} \\end{bmatrix}}_X \u0026#43; \\underbrace{\\begin{bmatrix} 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \\\\ \\frac{1}{m} \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{1}{m} \\end{bmatrix}}_B \\underbrace{\\begin{bmatrix} f_x \\\\ f_z \\end{bmatrix}}_F \u0026#43; \\underbrace{\\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ -9.81 \\end{bmatrix}}_G \\end{equation} $$ Modeling Friction For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation.\n","keywords":["control"],"articleBody":"In this post, we will add 1-dimensional coulomb friction to our simulation.\nFirst off, we’re going to need to allow movement in the horizontal direction. Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.\n$$ \\begin{equation} \\underbrace{\\begin{bmatrix} \\dot{x} \\\\ \\dot{z} \\\\ \\ddot{x} \\\\ \\ddot{z} \\end{bmatrix}}_{\\dot{X}} = \\underbrace{\\begin{bmatrix} 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ \\end{bmatrix}}_A \\underbrace{\\begin{bmatrix} x \\\\ z \\\\ \\dot{x} \\\\ \\dot{z} \\end{bmatrix}}_X + \\underbrace{\\begin{bmatrix} 0 \u0026 0 \\\\ 0 \u0026 0 \\\\ \\frac{1}{m} \u0026 0 \\\\ 0 \u0026 \\frac{1}{m} \\end{bmatrix}}_B \\underbrace{\\begin{bmatrix} f_x \\\\ f_z \\end{bmatrix}}_F + \\underbrace{\\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ -9.81 \\end{bmatrix}}_G \\end{equation} $$ Modeling Friction For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation.\n$$ \\begin{equation} f_x = -\\mu f_z \\text{sign}(\\dot{x}) \\end{equation} $$\nAlthough you are probably already familiar with this equation, it’s deceptively difficult to model because it has several discontinuities. Check out what happens when an object slides to a stop:\nAs your object transitions from slipping to sticking, your acceleration $\\ddot{x}$ and friction force $f_x$ jump from constant values to zero. Budge the object in either direction and your friction force will shoot to a constant positive or negative value on a dime.\nBecause the relationship between friction and speed is tricky to model, we need to split this equation up a bit. Firstly, we define the magnitude of the friction force as follows.\n$$ \\begin{equation} ||f_x|| \\leq \\mu f_z \\end{equation} $$\nYou may be wondering how the magnitude of friction can be less than $\\mu f_z$ all of a sudden. Well think about what happens when the object stops. Its friction force can’t be proportional to the normal force anymore, or it would never stop moving! To enforce $f_x = 0$ when the object is stopped, we’re going to use a Lagrange multiplier, $\\lambda_k$, which represents the magnitude of the tangential ground velocity at timestep $k$.\n$$ \\begin{equation} \\lambda_k (\\mu f_z - ||f_x||) = 0 \\end{equation} $$\nAs you can see, we are constraining $f_x$ so that it can only be zero when the tangential velocity is zero.\nThe magnitude of tangential velocity $\\lambda_k$ is defined as shown. Eq. (5) is pulling double duty because it also enforces that $f_x$ must point in the opposite direction of $\\dot{x}_k$.\n$$ \\begin{equation} \\dot{x}_k + \\lambda_k \\frac{f_x}{||f_x||} = 0 \\end{equation} $$\n$$ \\begin{equation} \\lambda_k \\geq 0 \\end{equation} $$\nThe Optimization Problem Just like last time, there are a few hacks we have to use to make the optimization problem run well with IPOPT. Firstly, we have to define a “smooth square root” function, $\\text{ssqrt}(x)$, as shown, to make norm functions less discontinuous. $\\epsilon$ is an arbitrarily small constant that we will make equal to the solver tolerance.\n$$ \\begin{equation} \\text{ssqrt}(x) = \\sqrt{x + \\epsilon^2} - \\epsilon \\end{equation} $$\n$$ \\begin{equation} || f_x || \\approx \\text{ssqrt}(f_x^2) \\end{equation} $$\nThe optimization problem is as follows.\n$$ \\begin{align} \\min_{X_{k+1}, f_z, f_x, s_1, s_2} \\quad \u0026 s_1^2 + s_2^2 \\\\ \\textrm{s.t.} \\quad \u0026 A_dX_k + B_dF_k + G_d - X_{k+1} = 0 \\\\ \u0026 s_1 - f_z z_{k+1} \\geq 0 \\\\ \u0026 z_{k+1} \\geq 0 \\\\ \u0026 f_z \\geq 0 \\\\ \u0026 s_1 \\geq 0 \\\\ \u0026 \\dot{x}_k + \\lambda_k \\frac{f_x}{\\text{ssqrt}(f_x^2) + \\epsilon} = 0 \\\\ \u0026 \\mu f_z - \\text{ssqrt}(f_x^2) \\geq 0 \\\\ \u0026 s_2 - \\lambda_k (\\mu f_z - \\text{ssqrt}(f_x^2)) \\geq 0 \\\\ \u0026 s_2 \\geq 0 \\\\ \u0026 \\lambda_k \\geq 0 \\end{align} $$ An explanation of what’s going on here:\nEqs. (10) through (14) are the contact constraints we covered in the last post. The original slack variable is now denoted as $s_1$. Eq. (15) is Eq. (5), but smoothed, plus an additional $\\epsilon$ to prevent division by zero. Eq. (16) is Eq. (3) smoothed. Eq. (17) is Eq. (4) with a second slack variable, $s_2$. Note that I am using $f_x$ and $f_z$ to refer to the elements of the force vector at timestep $k$ to avoid complicating the notation.\n$$ \\begin{equation} F_k = \\begin{bmatrix} f_x \\\\ f_z \\end{bmatrix} \\end{equation} $$ Furthermore, assume that any slack variables mentioned ($s_1$ and $s_2$) are also taken at timestep $k$.\nNow that that’s out of the way, let’s look at the code.\nThe Code We start out by defining the “smooth square root” function, the solver tolerance, the 2D dynamics, and the integrator.\nimport numpy as np import casadi as cs import plotting ϵ = 1e-4 def smoothsqrt(x): return cs.sqrt(x + ϵ * ϵ) - ϵ n_a = 4 # length of state vector n_u = 2 # length of control vector m = 10 # mass of the particle in kg g = 9.81 # gravitational constant A = np.array([[0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0]]) B = np.array([[0, 0], [0, 0], [1 / m, 0], [0, 1 / m]]) G = np.array([[0, 0, 0, -g]]).T dt = 0.001 # timestep size mu = 0.1 # coefficient of friction def dynamics_ct(X, U): dX = A @ X + B @ U + G.flatten() return dX def integrator_euler_semi_implicit(dyn_ct, xk, uk, xk1): xk_semi = cs.SX.zeros(n_a) xk_semi[:2] = xk[:2] xk_semi[2:] = xk1[2:] X_next = xk + dt * dyn_ct(xk_semi, uk) return X_next Next, we set up the solver.\nN = 1200 # number of timesteps X_hist = np.zeros((N, n_a)) # array of state vectors for each timestep Fx_hist = np.zeros(N) # array of x friction forces for each timestep Fz_hist = np.zeros(N) # array of z GRF forces for each timestep X_hist[0, :] = np.array([[0, 1, 1, 0]]) U_hist = np.zeros((N - 1, n_u)) # array of control vectors for each timestep # initialize casadi variables Xk1 = cs.SX.sym(\"Xk1\", n_a) # X(k+1), state at next timestep F = cs.SX.sym(\"F\", n_u) # forces s1 = cs.SX.sym(\"s1\", 1) # slack variable 1 s2 = cs.SX.sym(\"s2\", 1) # slack variable 2 lam = cs.SX.sym(\"lam\", 1) # lagrange mult for ground vel X = cs.SX.sym(\"X\", n_a) # state U = cs.SX.sym(\"U\", n_u) # controls xk = X[0] zk = X[1] dxk = X[2] Fx = F[0] # friction force Fz = F[1] # grf xk1 = Xk1[0] # horz pos zk1 = Xk1[1] # vert pos # objective function obj = s1**2 + s2**2 constr = [] # init constraints # dynamics constr = cs.vertcat( constr, cs.SX(integrator_euler_semi_implicit(dynamics_ct, X, U + F, Xk1) - Xk1) ) # tang. gnd vel is zero if GRF is zero but is otherwise equal to dx # max dissipation constr = cs.vertcat(constr, cs.SX(dxk + lam * Fx / (smoothsqrt(Fx * Fx) + ϵ))) # primal feasibility primal_friction = mu * Fz - smoothsqrt(Fx * Fx) # uN = Ff constr = cs.vertcat(constr, cs.SX(primal_friction)) # friction cone # relaxed complementarity aka compl. slackness constr = cs.vertcat(constr, cs.SX(s1 - Fz * zk1)) # ground penetration constr = cs.vertcat(constr, cs.SX(s2 - lam * primal_friction)) # friction opt_variables = cs.vertcat(Xk1, F, s1, s2, lam) parameters = cs.vertcat(X, U) lcp = {\"x\": opt_variables, \"p\": parameters, \"f\": obj, \"g\": constr} opts = { \"print_time\": 0, \"ipopt.print_level\": 0, \"ipopt.tol\": ϵ, \"ipopt.max_iter\": 2000, } solver = cs.nlpsol(\"S\", \"ipopt\", lcp, opts) Then we define our constraint bounds.\nn_var = np.shape(opt_variables)[0] n_par = np.shape(parameters)[0] n_g = np.shape(constr)[0] # variable bounds ubx = [1e10] * n_var lbx = [0] * n_var # dual feasibility lbx[0] = -1e10 # set x unlimited lbx[2] = -1e10 # set dx unlimited lbx[3] = -1e10 # set dz unlimited lbx[n_a] = -1e10 # set Fx unlimited # constraint bounds ubg = [1e10] * n_g ubg[0:n_a] = np.zeros(n_a) # set dynamics = 0 ubg[n_a] = 0 # set max dissipation = 0 lbg = [0] * n_g Finally, we step through the simulation.\n# run the sim p_values = np.zeros(n_par) x0_values = np.zeros(n_var) s1_hist = np.zeros(N) s2_hist = np.zeros(N) lam_hist = np.zeros(N) for k in range(N - 1): print(\"timestep = \", k) p_values[:n_a] = X_hist[k, :] p_values[n_a:] = U_hist[k, :] x0_values[:n_a] = X_hist[k, :] sol = solver(lbx=lbx, ubx=ubx, lbg=lbg, ubg=ubg, p=p_values, x0=x0_values) X_hist[k + 1, :] = np.reshape(sol[\"x\"][0:n_a], (-1,)) Fx_hist[k] = sol[\"x\"][n_a] Fz_hist[k] = sol[\"x\"][n_a + 1] s1_hist[k] = sol[\"x\"][n_a + 2] s2_hist[k] = sol[\"x\"][n_a + 3] lam_hist[k] = sol[\"x\"][n_a + 4] x_hist = X_hist[:, 0] z_hist = X_hist[:, 1] dx_hist = X_hist[:, 2] dz_hist = X_hist[:, 3] Click here for the full code.\nHere’s the result.\nNeat! Although the plot looks a little messy–again, IPOPT is not really the right solver for this.\nA Note on Friction with Hybrid and Smooth Contact With the smooth and hybrid contact models, friction is simple enough that I’m not going to cover them here. I’m just going to provide example code below.\n2D Hybrid Contact + Friction\n2D Smooth Contact + Friction\nAppendix If you want to learn more about this stuff, check out these sources.\n16-715: Simulating Coulomb Friction\nSIGGRAPH'22 Course: Contact and Friction Simulation for Computer Graphics\n","wordCount":"1495","inLanguage":"en","datePublished":"2025-01-20T00:00:00Z","dateModified":"2025-01-20T00:00:00Z","author":{"@type":"Person","name":"Ben Bokser"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbokser.github.io/posts/2025-01-20/"},"publisher":{"@type":"Organization","name":"Ben Bokser's Blog","logo":{"@type":"ImageObject","url":"https://bbokser.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbokser.github.io/ accesskey=h title="Ben Bokser (Alt + H)">Ben Bokser</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbokser.github.io/ title=Posts><span>Posts</span></a></li><li><a href=https://bbokser.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bbokser.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://benbokser.com/ title=Portfolio><span>Portfolio</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbokser.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbokser.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Intro to Robot Simulation, Part 3: Friction</h1><div class=post-meta><span title='2025-01-20 00:00:00 +0000 UTC'>January 20, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Ben Bokser&nbsp;|&nbsp;<a href=https://github.com/bbokser/bbokser.github.io/tree/main/content/posts/2025-01-20.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#modeling-friction aria-label="Modeling Friction">Modeling Friction</a></li><li><a href=#the-optimization-problem aria-label="The Optimization Problem">The Optimization Problem</a><ul><li><a href=#the-code aria-label="The Code">The Code</a></li></ul></li><li><a href=#a-note-on-friction-with-hybrid-and-smooth-contact aria-label="A Note on Friction with Hybrid and Smooth Contact">A Note on Friction with Hybrid and Smooth Contact</a></li><li><a href=#appendix aria-label=Appendix>Appendix</a></li></ul></div></details></div><div class=post-content><p>In this post, we will add 1-dimensional coulomb friction to our simulation.</p><p>First off, we&rsquo;re going to need to allow movement in the horizontal direction.
Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.</p>$$
\begin{equation}
\underbrace{\begin{bmatrix} \dot{x} \\ \dot{z} \\ \ddot{x} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} =
\underbrace{\begin{bmatrix}
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
\end{bmatrix}}_A
\underbrace{\begin{bmatrix}
x \\
z \\
\dot{x} \\
\dot{z}
\end{bmatrix}}_X
+ \underbrace{\begin{bmatrix}
0 & 0 \\
0 & 0 \\
\frac{1}{m} & 0 \\
0 & \frac{1}{m}
\end{bmatrix}}_B
\underbrace{\begin{bmatrix}
f_x \\
f_z
\end{bmatrix}}_F
+ \underbrace{\begin{bmatrix}
0 \\
0 \\
0 \\
-9.81
\end{bmatrix}}_G
\end{equation}
$$<h2 id=modeling-friction>Modeling Friction<a hidden class=anchor aria-hidden=true href=#modeling-friction>#</a></h2><p>For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation.</p><p>$$
\begin{equation}
f_x = -\mu f_z \text{sign}(\dot{x})
\end{equation}
$$</p><p>Although you are probably already familiar with this equation, it&rsquo;s deceptively difficult to model because it has several discontinuities.
Check out what happens when an object slides to a stop:</p><p><img loading=lazy src=/images/2025-01-20/friction.png></p><p>As your object transitions from slipping to sticking, your acceleration $\ddot{x}$ and friction force $f_x$ jump from constant values to zero. Budge the object in either direction and your friction force will shoot to a constant positive or negative value on a dime.</p><p>Because the relationship between friction and speed is tricky to model, we need to split this equation up a bit. Firstly, we define the magnitude of the friction force as follows.</p><p>$$
\begin{equation}
||f_x|| \leq \mu f_z
\end{equation}
$$</p><p>You may be wondering how the magnitude of friction can be <em>less than</em> $\mu f_z$ all of a sudden. Well think about what happens when the object stops. Its friction force can&rsquo;t be proportional to the normal force anymore, or it would never stop moving! To enforce $f_x = 0$ when the object is stopped, we&rsquo;re going to use a <a href=https://en.wikipedia.org/wiki/Lagrange_multiplier>Lagrange multiplier</a>, $\lambda_k$, which represents the magnitude of the tangential ground velocity at timestep $k$.</p><p>$$
\begin{equation}
\lambda_k (\mu f_z - ||f_x||) = 0
\end{equation}
$$</p><p>As you can see, we are constraining $f_x$ so that it can only be zero when the tangential velocity is zero.</p><p>The magnitude of tangential velocity $\lambda_k$ is defined as shown. Eq. (5) is pulling double duty because it also enforces that $f_x$ must point in the opposite direction of $\dot{x}_k$.</p><p>$$
\begin{equation}
\dot{x}_k + \lambda_k \frac{f_x}{||f_x||} = 0
\end{equation}
$$</p><p>$$
\begin{equation}
\lambda_k \geq 0
\end{equation}
$$</p><h2 id=the-optimization-problem>The Optimization Problem<a hidden class=anchor aria-hidden=true href=#the-optimization-problem>#</a></h2><p>Just like last time, there are a few hacks we have to use to make the optimization problem run well with IPOPT. Firstly, we have to define a &ldquo;smooth square root&rdquo; function, $\text{ssqrt}(x)$, as shown, to make norm functions less discontinuous. $\epsilon$ is an arbitrarily small constant that we will make equal to the solver tolerance.</p><p>$$
\begin{equation}
\text{ssqrt}(x) = \sqrt{x + \epsilon^2} - \epsilon
\end{equation}
$$</p><p>$$
\begin{equation}
|| f_x || \approx \text{ssqrt}(f_x^2)
\end{equation}
$$</p><p>The optimization problem is as follows.</p>$$
\begin{align}
\min_{X_{k+1}, f_z, f_x, s_1, s_2} \quad & s_1^2 + s_2^2 \\
\textrm{s.t.} \quad
& A_dX_k + B_dF_k + G_d - X_{k+1} = 0 \\
& s_1 - f_z z_{k+1} \geq 0 \\
& z_{k+1} \geq 0 \\
& f_z \geq 0 \\
& s_1 \geq 0 \\
& \dot{x}_k + \lambda_k \frac{f_x}{\text{ssqrt}(f_x^2) + \epsilon} = 0 \\
& \mu f_z - \text{ssqrt}(f_x^2) \geq 0 \\
& s_2 - \lambda_k (\mu f_z - \text{ssqrt}(f_x^2)) \geq 0 \\
& s_2 \geq 0 \\
& \lambda_k \geq 0
\end{align}
$$<p>An explanation of what&rsquo;s going on here:</p><ul><li>Eqs. (10) through (14) are the contact constraints we covered in the last post. The original slack variable is now denoted as $s_1$.</li><li>Eq. (15) is Eq. (5), but smoothed, plus an additional $\epsilon$ to prevent division by zero.</li><li>Eq. (16) is Eq. (3) smoothed.</li><li>Eq. (17) is Eq. (4) with a second slack variable, $s_2$.</li></ul><p>Note that I am using $f_x$ and $f_z$ to refer to the elements of the force vector at timestep $k$ to avoid complicating the notation.</p>$$
\begin{equation}
F_k = \begin{bmatrix}
f_x \\
f_z
\end{bmatrix}
\end{equation}
$$<p>Furthermore, assume that any slack variables mentioned ($s_1$ and $s_2$) are also taken at timestep $k$.</p><p>Now that that&rsquo;s out of the way, let&rsquo;s look at the code.</p><h3 id=the-code>The Code<a hidden class=anchor aria-hidden=true href=#the-code>#</a></h3><p>We start out by defining the &ldquo;smooth square root&rdquo; function, the solver tolerance, the 2D dynamics, and the integrator.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> casadi <span style=color:#66d9ef>as</span> cs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> plotting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ϵ <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>smoothsqrt</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cs<span style=color:#f92672>.</span>sqrt(x <span style=color:#f92672>+</span> ϵ <span style=color:#f92672>*</span> ϵ) <span style=color:#f92672>-</span> ϵ
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n_a <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>  <span style=color:#75715e># length of state vector</span>
</span></span><span style=display:flex><span>n_u <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># length of control vector</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># mass of the particle in kg</span>
</span></span><span style=display:flex><span>g <span style=color:#f92672>=</span> <span style=color:#ae81ff>9.81</span>  <span style=color:#75715e># gravitational constant</span>
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> m, <span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> m]])
</span></span><span style=display:flex><span>G <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span>g]])<span style=color:#f92672>.</span>T
</span></span><span style=display:flex><span>dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>  <span style=color:#75715e># timestep size</span>
</span></span><span style=display:flex><span>mu <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>  <span style=color:#75715e># coefficient of friction</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_ct</span>(X, U):
</span></span><span style=display:flex><span>    dX <span style=color:#f92672>=</span> A <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> B <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> G<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_euler_semi_implicit</span>(dyn_ct, xk, uk, xk1):
</span></span><span style=display:flex><span>    xk_semi <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>zeros(n_a)
</span></span><span style=display:flex><span>    xk_semi[:<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> xk[:<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    xk_semi[<span style=color:#ae81ff>2</span>:] <span style=color:#f92672>=</span> xk1[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> dyn_ct(xk_semi, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span></code></pre></div><p>Next, we set up the solver.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1200</span>  <span style=color:#75715e># number of timesteps</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_a))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>Fx_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)  <span style=color:#75715e># array of x friction forces for each timestep</span>
</span></span><span style=display:flex><span>Fz_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)  <span style=color:#75715e># array of z GRF forces for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>U_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, n_u))  <span style=color:#75715e># array of control vectors for each timestep</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># initialize casadi variables</span>
</span></span><span style=display:flex><span>Xk1 <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;Xk1&#34;</span>, n_a)  <span style=color:#75715e># X(k+1), state at next timestep</span>
</span></span><span style=display:flex><span>F <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;F&#34;</span>, n_u)  <span style=color:#75715e># forces</span>
</span></span><span style=display:flex><span>s1 <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;s1&#34;</span>, <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># slack variable 1</span>
</span></span><span style=display:flex><span>s2 <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;s2&#34;</span>, <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># slack variable 2</span>
</span></span><span style=display:flex><span>lam <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;lam&#34;</span>, <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># lagrange mult for ground vel</span>
</span></span><span style=display:flex><span>X <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;X&#34;</span>, n_a)  <span style=color:#75715e># state</span>
</span></span><span style=display:flex><span>U <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>SX<span style=color:#f92672>.</span>sym(<span style=color:#e6db74>&#34;U&#34;</span>, n_u)  <span style=color:#75715e># controls</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>xk <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>zk <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>dxk <span style=color:#f92672>=</span> X[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>Fx <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e># friction force</span>
</span></span><span style=display:flex><span>Fz <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>]  <span style=color:#75715e># grf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>xk1 <span style=color:#f92672>=</span> Xk1[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e># horz pos</span>
</span></span><span style=display:flex><span>zk1 <span style=color:#f92672>=</span> Xk1[<span style=color:#ae81ff>1</span>]  <span style=color:#75715e># vert pos</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># objective function</span>
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> s1<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> s2<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> []  <span style=color:#75715e># init constraints</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dynamics</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(
</span></span><span style=display:flex><span>    constr, cs<span style=color:#f92672>.</span>SX(integrator_euler_semi_implicit(dynamics_ct, X, U <span style=color:#f92672>+</span> F, Xk1) <span style=color:#f92672>-</span> Xk1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># tang. gnd vel is zero if GRF is zero but is otherwise equal to dx</span>
</span></span><span style=display:flex><span><span style=color:#75715e># max dissipation</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(constr, cs<span style=color:#f92672>.</span>SX(dxk <span style=color:#f92672>+</span> lam <span style=color:#f92672>*</span> Fx <span style=color:#f92672>/</span> (smoothsqrt(Fx <span style=color:#f92672>*</span> Fx) <span style=color:#f92672>+</span> ϵ)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># primal feasibility</span>
</span></span><span style=display:flex><span>primal_friction <span style=color:#f92672>=</span> mu <span style=color:#f92672>*</span> Fz <span style=color:#f92672>-</span> smoothsqrt(Fx <span style=color:#f92672>*</span> Fx)  <span style=color:#75715e># uN = Ff</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(constr, cs<span style=color:#f92672>.</span>SX(primal_friction))  <span style=color:#75715e># friction cone</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># relaxed complementarity aka compl. slackness</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(constr, cs<span style=color:#f92672>.</span>SX(s1 <span style=color:#f92672>-</span> Fz <span style=color:#f92672>*</span> zk1))  <span style=color:#75715e># ground penetration</span>
</span></span><span style=display:flex><span>constr <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(constr, cs<span style=color:#f92672>.</span>SX(s2 <span style=color:#f92672>-</span> lam <span style=color:#f92672>*</span> primal_friction))  <span style=color:#75715e># friction</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>opt_variables <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(Xk1, F, s1, s2, lam)
</span></span><span style=display:flex><span>parameters <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>vertcat(X, U)
</span></span><span style=display:flex><span>lcp <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;x&#34;</span>: opt_variables, <span style=color:#e6db74>&#34;p&#34;</span>: parameters, <span style=color:#e6db74>&#34;f&#34;</span>: obj, <span style=color:#e6db74>&#34;g&#34;</span>: constr}
</span></span><span style=display:flex><span>opts <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;print_time&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.print_level&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.tol&#34;</span>: ϵ,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ipopt.max_iter&#34;</span>: <span style=color:#ae81ff>2000</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>solver <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>nlpsol(<span style=color:#e6db74>&#34;S&#34;</span>, <span style=color:#e6db74>&#34;ipopt&#34;</span>, lcp, opts)
</span></span></code></pre></div><p>Then we define our constraint bounds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>n_var <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(opt_variables)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>n_par <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(parameters)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>n_g <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>shape(constr)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># variable bounds</span>
</span></span><span style=display:flex><span>ubx <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1e10</span>] <span style=color:#f92672>*</span> n_var
</span></span><span style=display:flex><span>lbx <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n_var  <span style=color:#75715e># dual feasibility</span>
</span></span><span style=display:flex><span>lbx[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1e10</span>  <span style=color:#75715e># set x unlimited</span>
</span></span><span style=display:flex><span>lbx[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1e10</span>  <span style=color:#75715e># set dx unlimited</span>
</span></span><span style=display:flex><span>lbx[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1e10</span>  <span style=color:#75715e># set dz unlimited</span>
</span></span><span style=display:flex><span>lbx[n_a] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1e10</span>  <span style=color:#75715e># set Fx unlimited</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># constraint bounds</span>
</span></span><span style=display:flex><span>ubg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1e10</span>] <span style=color:#f92672>*</span> n_g
</span></span><span style=display:flex><span>ubg[<span style=color:#ae81ff>0</span>:n_a] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(n_a)  <span style=color:#75715e># set dynamics = 0</span>
</span></span><span style=display:flex><span>ubg[n_a] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># set max dissipation = 0</span>
</span></span><span style=display:flex><span>lbg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n_g
</span></span></code></pre></div><p>Finally, we step through the simulation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># run the sim</span>
</span></span><span style=display:flex><span>p_values <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(n_par)
</span></span><span style=display:flex><span>x0_values <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(n_var)
</span></span><span style=display:flex><span>s1_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)
</span></span><span style=display:flex><span>s2_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)
</span></span><span style=display:flex><span>lam_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;timestep = &#34;</span>, k)
</span></span><span style=display:flex><span>    p_values[:n_a] <span style=color:#f92672>=</span> X_hist[k, :]
</span></span><span style=display:flex><span>    p_values[n_a:] <span style=color:#f92672>=</span> U_hist[k, :]
</span></span><span style=display:flex><span>    x0_values[:n_a] <span style=color:#f92672>=</span> X_hist[k, :]
</span></span><span style=display:flex><span>    sol <span style=color:#f92672>=</span> solver(lbx<span style=color:#f92672>=</span>lbx, ubx<span style=color:#f92672>=</span>ubx, lbg<span style=color:#f92672>=</span>lbg, ubg<span style=color:#f92672>=</span>ubg, p<span style=color:#f92672>=</span>p_values, x0<span style=color:#f92672>=</span>x0_values)
</span></span><span style=display:flex><span>    X_hist[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>reshape(sol[<span style=color:#e6db74>&#34;x&#34;</span>][<span style=color:#ae81ff>0</span>:n_a], (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,))
</span></span><span style=display:flex><span>    Fx_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a]
</span></span><span style=display:flex><span>    Fz_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    s1_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    s2_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>    lam_hist[k] <span style=color:#f92672>=</span> sol[<span style=color:#e6db74>&#34;x&#34;</span>][n_a <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>z_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>dx_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>dz_hist <span style=color:#f92672>=</span> X_hist[:, <span style=color:#ae81ff>3</span>]
</span></span></code></pre></div><p>Click <a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_2d_confr_tstep.py>here</a> for the full code.</p><p>Here&rsquo;s the result.</p><p><img loading=lazy src=/images/2025-01-20/2d_confr_tstep.gif#center>
<img loading=lazy src=/images/2025-01-20/2d_confr_tstep.png></p><p>Neat! Although the plot looks a little messy&ndash;again, IPOPT is not really the right solver for this.</p><h2 id=a-note-on-friction-with-hybrid-and-smooth-contact>A Note on Friction with Hybrid and Smooth Contact<a hidden class=anchor aria-hidden=true href=#a-note-on-friction-with-hybrid-and-smooth-contact>#</a></h2><p>With the smooth and hybrid contact models, friction is simple enough that I&rsquo;m not going to cover them here.
I&rsquo;m just going to provide example code below.</p><p><a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_2d_confr_hybrid.py>2D Hybrid Contact + Friction</a></p><p><a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_2d_confr_smooth.py>2D Smooth Contact + Friction</a></p><h2 id=appendix>Appendix<a hidden class=anchor aria-hidden=true href=#appendix>#</a></h2><p>If you want to learn more about this stuff, check out these sources.</p><p><a href="https://youtu.be/wMW59tnRlDE?feature=shared">16-715: Simulating Coulomb Friction</a></p><p><a href=https://siggraphcontact.github.io/>SIGGRAPH'22 Course: Contact and Friction Simulation for Computer Graphics</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bbokser.github.io/tags/control/>Control</a></li></ul><nav class=paginav><a class=next href=https://bbokser.github.io/posts/2024-12-31/><span class=title>Next »</span><br><span>Intro to Robot Simulation, Part 2: Contact</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on x" href="https://x.com/intent/tweet/?text=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f&amp;hashtags=control"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f&amp;title=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction&amp;summary=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction&amp;source=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f&title=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on whatsapp" href="https://api.whatsapp.com/send?text=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction%20-%20https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on telegram" href="https://telegram.me/share/url?text=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 3: Friction on ycombinator" href="https://news.ycombinator.com/submitlink?t=Intro%20to%20Robot%20Simulation%2c%20Part%203%3a%20Friction&u=https%3a%2f%2fbbokser.github.io%2fposts%2f2025-01-20%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div class=giscus><script>function getGiscusTheme(){const e=localStorage.getItem("pref-theme"),t=e==null||e=="light"?"light":"dark";return t}function setGiscusTheme(){function e(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}e({setConfig:{theme:getGiscusTheme()=="light"?"dark":"light"}})}const attrs={src:"https://giscus.app/client.js","data-repo":"bbokser/bbokser.github.io","data-repo-id":"R_kgDOGxN6Pg","data-category":"Announcements","data-category-id":"DIC_kwDOIWVKbs4CSTz_","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getGiscusTheme(),"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(attrs).forEach(([e,t])=>giscusScript.setAttribute(e,t)),document.body.appendChild(giscusScript);const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",setGiscusTheme)</script><noscript>Please enable JavaScript to view the comments</noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://bbokser.github.io/>Ben Bokser's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>