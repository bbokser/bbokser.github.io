<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro to Robot Simulation, Part 1: Point Masses | Ben Bokser's Blog</title>
<meta name=keywords content="control"><meta name=description content="{{ .TableOfContents }}
So, you want to write your own dynamic robot simulation from scratch.
Let&rsquo;s start with one of the simplest possible dynamical systems: a vertically constrained point mass.
Think of it as a rocket locked to a linear rail.

The rocket cannot rotate or translate laterally; it can only move up or down,
and can it only control this by either exerting an upward force or letting gravity take its course."><meta name=author content="Ben Bokser"><link rel=canonical href=https://bbokser.github.io/posts/2024-02-18/><link crossorigin=anonymous href=/assets/css/stylesheet.f5e4015d42de28790ef5dd03b8bc8041968f8b08d6b8a41faded98c8e9953483.css integrity="sha256-9eQBXULeKHkO9d0DuLyAQZaPiwjWuKQfre2YyOmVNIM=" rel="preload stylesheet" as=style><link rel=icon href=https://bbokser.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbokser.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bbokser.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bbokser.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bbokser.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbokser.github.io/posts/2024-02-18/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://bbokser.github.io/posts/2024-02-18/"><meta property="og:site_name" content="Ben Bokser's Blog"><meta property="og:title" content="Intro to Robot Simulation, Part 1: Point Masses"><meta property="og:description" content="{{ .TableOfContents }}
So, you want to write your own dynamic robot simulation from scratch.
Let’s start with one of the simplest possible dynamical systems: a vertically constrained point mass. Think of it as a rocket locked to a linear rail.
The rocket cannot rotate or translate laterally; it can only move up or down, and can it only control this by either exerting an upward force or letting gravity take its course."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-18T00:00:00+00:00"><meta property="article:tag" content="Control"><meta property="og:image" content="https://bbokser.github.io/images/2024-02-18/rocket.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbokser.github.io/images/2024-02-18/rocket.png"><meta name=twitter:title content="Intro to Robot Simulation, Part 1: Point Masses"><meta name=twitter:description content="{{ .TableOfContents }}
So, you want to write your own dynamic robot simulation from scratch.
Let&rsquo;s start with one of the simplest possible dynamical systems: a vertically constrained point mass.
Think of it as a rocket locked to a linear rail.

The rocket cannot rotate or translate laterally; it can only move up or down,
and can it only control this by either exerting an upward force or letting gravity take its course."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbokser.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Intro to Robot Simulation, Part 1: Point Masses","item":"https://bbokser.github.io/posts/2024-02-18/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro to Robot Simulation, Part 1: Point Masses","name":"Intro to Robot Simulation, Part 1: Point Masses","description":"{{ .TableOfContents }}\nSo, you want to write your own dynamic robot simulation from scratch.\nLet\u0026rsquo;s start with one of the simplest possible dynamical systems: a vertically constrained point mass. Think of it as a rocket locked to a linear rail.\nThe rocket cannot rotate or translate laterally; it can only move up or down, and can it only control this by either exerting an upward force or letting gravity take its course.\n","keywords":["control"],"articleBody":"{{ .TableOfContents }}\nSo, you want to write your own dynamic robot simulation from scratch.\nLet’s start with one of the simplest possible dynamical systems: a vertically constrained point mass. Think of it as a rocket locked to a linear rail.\nThe rocket cannot rotate or translate laterally; it can only move up or down, and can it only control this by either exerting an upward force or letting gravity take its course.\nTherefore, we can solve for the acceleration of the rocket as follows:\n$$ \\begin{equation} \\ddot{z} = \\frac{u}{m} - 9.81 \\end{equation} $$\nWhere $\\ddot{z}$ is the rocket’s vertical acceleration, $u$ is the force exerted by the rocket, $m$ is the rocket’s mass, and the additional term is gravity.\nWriting a CT State Space Model We begin by rewriting Eq(1) as a continuous-time (CT) linear state space representation of the system. Our state vector, usually denoted by $X$, is composed of the vertical position $z$ and its vertical velocity $\\dot{z}$.\n$$ \\begin{equation} X = \\begin{bmatrix} z \\\\ \\dot{z} \\end{bmatrix} \\end{equation} $$ The purpose of the CT state-space representation is to solve for the derivative of $X$:\n$$ \\begin{equation} \\dot{X} = \\begin{bmatrix} \\dot{z} \\\\ \\ddot{z} \\end{bmatrix} \\end{equation} $$ For the rocket-on-a-rail, this can be solved as such:\n$$ \\begin{equation} \\underbrace{\\begin{bmatrix} \\dot{z} \\\\ \\ddot{z} \\end{bmatrix}}_{\\dot{X}} = \\underbrace{\\begin{bmatrix} 0 \u0026 1 \\\\ 0 \u0026 0 \\end{bmatrix}}_A \\underbrace{\\begin{bmatrix} z \\\\ \\dot{z} \\end{bmatrix}}_X + \\underbrace{\\begin{bmatrix} 0 \\\\ \\frac{1}{m} \\end{bmatrix}}_B u + \\underbrace{\\begin{bmatrix} 0 \\\\ -9.81 \\end{bmatrix}}_G \\end{equation} $$ Note the $A$ matrix (AKA “the state matrix”), which governs how $X$ affects $\\dot{X}$. In this case, the only relation is that $\\dot{z} = \\dot{z}$.\nSecondly, the B matrix (AKA “the input matrix”) governs how the control input $U$ affects $\\dot{X}.$\nFinally, the G matrix represents a disturbance, which in this case is the constant acceleration acting on the system due to gravity.\nFrom Continuous-Time to Discrete-Time Continuous-time state space models represent the dynamics of a system with respect to time. Let’s focus on the linear time-invariant (LTI) case to keep things simple (This means that the A and B matrices are not functions of time, e.g. $A(t)$).\n$$ \\begin{equation} \\dot{X}(t) = A X(t) + B U(t) \\end{equation} $$\nNow imagine if we wanted to simulate such a system. We would need to measure the state $X(t)$ for various values of $t$. This would not be possible, as we are only solving for its derivative, $\\dot{X}(t)$!\nLuckily, there is a solution for the LTI case that makes this possible:\n$$ \\begin{equation} X(t) = e^{(t - t_0)A} X(t_0) + \\int^t_{t_0} e^{A (t-\\tau)} B u(\\tau) d\\tau \\end{equation} $$\nThe problem, of course, is that it requires the calculation of a matrix exponential, $e^A$, the solution for which is an infinite series.\nThe main takeaway here is that any attempt to simulate a LTI state space system can be interpreted as an approximation of the matrix exponential. There are many ways to do this (at least nineteen!), but I will only cover a few here.\nOkay, anyway, we can solve for $X(t)$ now. But do we want to find $X$ for any arbitrary $t$? Actually, it is most convenient to “step” through time at a constant rate. The time between each step is known as a timestep and will be written as $dt$ here.\nWith this in mind, we should now be concerned with discrete timesteps $k$, and as such we rewrite the model in discretized form as follows: $$ \\begin{equation} X_{k+1} = A_d X_k + B_d U_k + G_d \\end{equation} $$\nNote that instead of calculating $\\dot{X}$, we are now attempting to calculate $X_{k+1}$, which is just $X$ at the next timestep.\nThe expm() Method The most obvious way to solve for the state at each timestep is to simply call a function that solves the matrix exponential. In this case, we use scipy.linalg.expm(). This also happens to be one the most accurate methods (although it’s still technically an approximation), and one of the most computationally expensive.\nThe code in this guide is written in Python. We will start by importing necessary libraries and defining the constants.\nimport numpy as np from scipy.linalg import expm import matplotlib.pyplot as plt n_x = 2 # length of state vector n_u = 1 # length of control vector m = 10 # mass of the rocket in kg A = np.array([[0, 1], [0, 0]]) B = np.array([[0], [1/m]]) G = np.array([[0], [-9.81]]) dt = 0.001 # timestep size Next, we calculate the discretized dynamics using expm(). Because expm() only accepts square matrices, and $B$ and $G$ are not square, we perform a little trick here where we merge $A$, $B$, and $G$ into one big square matrix using a few extra rows of zeros. Then we extract the discretized $A_d$, $B_d$, and $G_d$ from the result.\nABG = np.vstack((np.hstack((A, B, G)), np.zeros((n_u + 1, n_x + n_u + 1)))) M = expm(ABG * dt) Ad = M[0:n_x, 0:n_x] Bd = M[0:n_x, n_x:n_x + n_u] Gd = M[0:n_x, n_x + n_u:] def dynamics_dt(X, U): X_next = Ad @ X + Bd @ U + Gd.flatten() return X_next Now we can set the simulation up, run it, and plot the result.\nN = 1000 # number of timesteps X_hist = np.zeros((N, n_x)) # array of state vectors for each timestep X_hist[0, :] = np.array([[1, 0]]) U_hist = np.zeros((N-1, n_u)) # array of control vectors for each timestep for k in range(N-1): X_hist[k+1, :] = dynamics_dt(X_hist[k, :], U_hist[k, :]) plt.plot(range(N), X_hist[:, 0], label='expm') plt.title('Body Position vs Time') plt.ylabel(\"z (m)\") plt.xlabel(\"timesteps\") plt.show() The full code can be found here. You should get the following result:\nAs you can see, the point mass accelerates downward due to gravity. Simple stuff.\nThe Explicit Euler Method There is a broad class of methods known as Runge-Kutta, which can be used to discretize any transient problem, including nonlinear ones. The explicit Euler method (AKA foward Euler method) is probably the simplest of those, which is why I am covering it here. Unlike the previous discretization method, it is extremely computationally efficient, albeit inaccurate and unstable. The explicit Euler method is the standard discretization method used in video games, where physical accuracy is considered “optional”.\nLike I said, the explicit Euler method is simple. It assumes that the state at the next timestep is simply the current state plus the state derivative multiplied by the timestep size. This makes a lot of intuitive sense.\n$$ \\begin{equation} X_{k+1} = X_k + \\dot{X_k}\\text{dt} \\end{equation} $$\nLet’s see how this looks in code:\ndef dynamics_ct(X, U): dX = A @ X + B @ U + G.flatten() return dX def integrator_euler(dyn_ct, xk, uk): X_next = xk + dt * dyn_ct(xk, uk) return X_next Now, replace the for loop from earlier with the following:\nfor k in range(N-1): X_hist[k+1, :] = integrator_euler(dynamics_ct, X_hist[k, :], U_hist[k, :]) Your resulting plot should look exactly the same.\nThe Fourth-Order Runge-Kutta Method Despite its computational efficiency, the explicit Euler method is not ideal for robotics. Higher-order Runge-Kutta methods are generally preferred due to their superior accuracy and stability. The fourth-order Runge-Kutta method (RK4) is one of the most popular.\nFor brevity, I won’t explain how/why it works here, but you can try it out by replacing the integrator_euler() function with the following:\ndef integrator_rk4(dyn_ct, xk, uk): f1 = dyn_ct(xk, uk) f2 = dyn_ct(xk + 0.5 * dt * f1, uk) f3 = dyn_ct(xk + 0.5 * dt * f2, uk) f4 = dyn_ct(xk + dt * f3, uk) return xk + (dt / 6.0) * (f1 + 2 * f2 + 2 * f3 + f4) For such a simple setup, you won’t notice much of a difference between these methods until you turn the timestep size way up. The following plot compares all three methods covered here using a timestep size of a tenth of a second.\nThe expm result should be taken as “ground truth”. As you can see, the explicit Euler method visibly diverges from “truth”, but it is still not possible to distinguish the RK4 results from expm.\nAdding Control One more thing. After the first half a second, let’s add a 1000N force to the control vector applied over the course of a quarter second and see what happens.\nN = 5000 # number of timesteps X_hist = np.zeros((N, n_x)) # array of state vectors for each timestep X_hist[0, :] = np.array([[1, 0]]) U_hist = np.zeros((N-1, n_u)) # array of control vectors for each timestep U_hist[500:750, :] = 1000 # HERE! for k in range(N-1): X_hist[k+1, :] = dynamics_dt(X_hist[k, :], U_hist[k, :]) Whee!\nNext Steps In the next part of this series, I will cover how contact is simulated, so that the point mass can bounce off the ground.\n","wordCount":"1446","inLanguage":"en","image":"https://bbokser.github.io/images/2024-02-18/rocket.png","datePublished":"2024-02-18T00:00:00Z","dateModified":"2024-02-18T00:00:00Z","author":{"@type":"Person","name":"Ben Bokser"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbokser.github.io/posts/2024-02-18/"},"publisher":{"@type":"Organization","name":"Ben Bokser's Blog","logo":{"@type":"ImageObject","url":"https://bbokser.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbokser.github.io/ accesskey=h title="Ben Bokser (Alt + H)">Ben Bokser</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbokser.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://bbokser.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bbokser.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://benbokser.com/ title=Portfolio><span>Portfolio</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbokser.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbokser.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Intro to Robot Simulation, Part 1: Point Masses</h1><div class=post-meta><span title='2024-02-18 00:00:00 +0000 UTC'>February 18, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Ben Bokser&nbsp;|&nbsp;<a href=https://github.com/bbokser/bbokser.github.io/tree/main/content/posts/2024-02-18.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://bbokser.github.io/images/2024-02-18/rocket.png alt=Rocket-on-rail><p>A rocket constrained to a linear rail</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#writing-a-ct-state-space-model aria-label="Writing a CT State Space Model">Writing a CT State Space Model</a></li><li><a href=#from-continuous-time-to-discrete-time aria-label="From Continuous-Time to Discrete-Time">From Continuous-Time to Discrete-Time</a><ul><li><a href=#the-expm-method aria-label="The expm() Method">The expm() Method</a></li><li><a href=#the-explicit-euler-method aria-label="The Explicit Euler Method">The Explicit Euler Method</a></li><li><a href=#the-fourth-order-runge-kutta-method aria-label="The Fourth-Order Runge-Kutta Method">The Fourth-Order Runge-Kutta Method</a></li></ul></li><li><a href=#adding-control aria-label="Adding Control">Adding Control</a></li><li><a href=#next-steps aria-label="Next Steps">Next Steps</a></li></ul></div></details></div><div class=post-content><p>{{ .TableOfContents }}</p><p>So, you want to write your own dynamic robot simulation from scratch.</p><p>Let&rsquo;s start with one of the simplest possible dynamical systems: a vertically constrained point mass.
Think of it as a rocket locked to a linear rail.</p><p><img loading=lazy src=/images/2024-02-18/rocket.png></p><p>The rocket cannot rotate or translate laterally; it can only move up or down,
and can it only control this by either exerting an upward force or letting gravity take its course.</p><p>Therefore, we can solve for the acceleration of the rocket as follows:</p><p>$$
\begin{equation}
\ddot{z} = \frac{u}{m} - 9.81
\end{equation}
$$</p><p>Where $\ddot{z}$ is the rocket&rsquo;s vertical acceleration, $u$ is the force exerted by the rocket, $m$ is the rocket&rsquo;s mass, and the additional term is gravity.</p><h2 id=writing-a-ct-state-space-model>Writing a CT State Space Model<a hidden class=anchor aria-hidden=true href=#writing-a-ct-state-space-model>#</a></h2><p>We begin by rewriting Eq(1) as a continuous-time (CT) linear state space representation of the system. Our state vector, usually denoted by $X$, is composed of the vertical position $z$ and its vertical velocity $\dot{z}$.</p>$$
\begin{equation}
X = \begin{bmatrix} z \\ \dot{z} \end{bmatrix}
\end{equation}
$$<p>The purpose of the CT state-space representation is to solve for the derivative of $X$:</p>$$
\begin{equation}
\dot{X} = \begin{bmatrix} \dot{z} \\ \ddot{z} \end{bmatrix}
\end{equation}
$$<p>For the rocket-on-a-rail, this can be solved as such:</p>$$
\begin{equation}
\underbrace{\begin{bmatrix} \dot{z} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} =
\underbrace{\begin{bmatrix}
0 & 1 \\
0 & 0
\end{bmatrix}}_A
\underbrace{\begin{bmatrix}
z \\
\dot{z}
\end{bmatrix}}_X
+ \underbrace{\begin{bmatrix}
0 \\
\frac{1}{m}
\end{bmatrix}}_B
u
+ \underbrace{\begin{bmatrix}
0 \\
-9.81
\end{bmatrix}}_G
\end{equation}
$$<p>Note the $A$ matrix (AKA &ldquo;the state matrix&rdquo;), which governs how $X$ affects $\dot{X}$. In this case, the only relation is that $\dot{z} = \dot{z}$.</p><p>Secondly, the B matrix (AKA &ldquo;the input matrix&rdquo;) governs how the control input $U$ affects $\dot{X}.$</p><p>Finally, the G matrix represents a disturbance, which in this case is the constant acceleration acting on the system due to gravity.</p><h2 id=from-continuous-time-to-discrete-time>From Continuous-Time to Discrete-Time<a hidden class=anchor aria-hidden=true href=#from-continuous-time-to-discrete-time>#</a></h2><p>Continuous-time state space models represent the dynamics of a system with respect to time. Let&rsquo;s focus on the linear time-invariant (LTI) case to keep things simple (This means that the A and B matrices are not functions of time, e.g. $A(t)$).</p><p>$$
\begin{equation}
\dot{X}(t) = A X(t) + B U(t)
\end{equation}
$$</p><p>Now imagine if we wanted to simulate such a system. We would need to measure the state $X(t)$ for various values of $t$. This would not be possible, as we are only solving for its derivative, $\dot{X}(t)$!</p><p>Luckily, there is a <a href=https://ocw.mit.edu/courses/6-241j-dynamic-systems-and-control-spring-2011/79f1a26e91a057181d225d2e1ffa0b57_MIT6_241JS11_chap11.pdf>solution for the LTI case</a> that makes this possible:</p><p>$$
\begin{equation}
X(t) = e^{(t - t_0)A} X(t_0) + \int^t_{t_0} e^{A (t-\tau)} B u(\tau) d\tau
\end{equation}
$$</p><p>The problem, of course, is that it requires the calculation of a matrix exponential, $e^A$, the solution for which is an infinite series.</p><p>The main takeaway here is that any attempt to simulate a LTI state space system can be interpreted as an <em>approximation</em> of the matrix exponential. There are many ways to do this (<a href=https://epubs.siam.org/doi/pdf/10.1137/1020098>at least nineteen!</a>), but I will only cover a few here.</p><p>Okay, anyway, we can solve for $X(t)$ now. But do we want to find $X$ for any arbitrary $t$? Actually, it is most convenient to &ldquo;step&rdquo; through time at a constant rate. The time between each step is known as a timestep and will be written as $dt$ here.</p><p>With this in mind, we should now be concerned with discrete timesteps $k$, and as such we rewrite the model in discretized form as follows:
$$
\begin{equation}
X_{k+1} = A_d X_k + B_d U_k + G_d
\end{equation}
$$</p><p>Note that instead of calculating $\dot{X}$, we are now attempting to calculate $X_{k+1}$, which is just $X$ at the next timestep.</p><h3 id=the-expm-method>The expm() Method<a hidden class=anchor aria-hidden=true href=#the-expm-method>#</a></h3><p>The most obvious way to solve for the state at each timestep is to simply call a function that solves the matrix exponential. In this case, we use <a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.expm.html><code>scipy.linalg.expm()</code></a>. This also happens to be one the most accurate methods (although it&rsquo;s still technically an approximation), and one of the most computationally expensive.</p><p>The code in this guide is written in Python. We will start by importing necessary libraries and defining the constants.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> scipy.linalg <span style=color:#f92672>import</span> expm
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># length of state vector</span>
</span></span><span style=display:flex><span>n_u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># length of control vector</span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># mass of the rocket in kg</span>
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>              [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>              [<span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>m]])
</span></span><span style=display:flex><span>G <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>9.81</span>]])
</span></span><span style=display:flex><span>dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>  <span style=color:#75715e># timestep size</span>
</span></span></code></pre></div><p>Next, we calculate the discretized dynamics using <code>expm()</code>. Because <code>expm()</code> only accepts square matrices, and $B$ and $G$ are not square, we perform a little trick here where we merge $A$, $B$, and $G$ into one big square matrix using a few extra rows of zeros. Then we extract the discretized $A_d$, $B_d$, and $G_d$ from the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>ABG <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>vstack((np<span style=color:#f92672>.</span>hstack((A, B, G)), np<span style=color:#f92672>.</span>zeros((n_u <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n_x <span style=color:#f92672>+</span> n_u <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>M <span style=color:#f92672>=</span> expm(ABG <span style=color:#f92672>*</span> dt)
</span></span><span style=display:flex><span>Ad <span style=color:#f92672>=</span> M[<span style=color:#ae81ff>0</span>:n_x, <span style=color:#ae81ff>0</span>:n_x]
</span></span><span style=display:flex><span>Bd <span style=color:#f92672>=</span> M[<span style=color:#ae81ff>0</span>:n_x, n_x:n_x <span style=color:#f92672>+</span> n_u]
</span></span><span style=display:flex><span>Gd <span style=color:#f92672>=</span> M[<span style=color:#ae81ff>0</span>:n_x, n_x <span style=color:#f92672>+</span> n_u:]   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_dt</span>(X, U):
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> Ad <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> Bd <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> Gd<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span></code></pre></div><p>Now we can set the simulation up, run it, and plot the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># number of timesteps</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_x))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>U_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, n_u)) <span style=color:#75715e># array of control vectors for each timestep</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    X_hist[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> dynamics_dt(X_hist[k, :], U_hist[k, :])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(range(N), X_hist[:, <span style=color:#ae81ff>0</span>], label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;expm&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#39;Body Position vs Time&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;z (m)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#34;timesteps&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>show()
</span></span></code></pre></div><p>The full code can be found <a href=https://github.com/bbokser/dynamic-sim-tutorial/blob/main/src/point_mass_1d_simple.py>here</a>.
You should get the following result:</p><p><img loading=lazy src=/images/2024-02-18/expm_plot.png></p><p>As you can see, the point mass accelerates downward due to gravity. Simple stuff.</p><h3 id=the-explicit-euler-method>The Explicit Euler Method<a hidden class=anchor aria-hidden=true href=#the-explicit-euler-method>#</a></h3><p>There is a broad class of methods known as Runge-Kutta, which can be used to discretize any transient problem, including nonlinear ones. The explicit Euler method (AKA foward Euler method) is probably the simplest of those, which is why I am covering it here. Unlike the previous discretization method, it is extremely computationally efficient, albeit inaccurate and unstable. The explicit Euler method is the standard discretization method used in video games, where physical accuracy is considered &ldquo;optional&rdquo;.</p><p>Like I said, the explicit Euler method is simple. It assumes that the state at the next timestep is simply the current state plus the state derivative multiplied by the timestep size. This makes a lot of intuitive sense.</p><p>$$
\begin{equation}
X_{k+1} = X_k + \dot{X_k}\text{dt}
\end{equation}
$$</p><p>Let&rsquo;s see how this looks in code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dynamics_ct</span>(X, U):
</span></span><span style=display:flex><span>    dX <span style=color:#f92672>=</span> A <span style=color:#f92672>@</span> X <span style=color:#f92672>+</span> B <span style=color:#f92672>@</span> U <span style=color:#f92672>+</span> G<span style=color:#f92672>.</span>flatten()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_euler</span>(dyn_ct, xk, uk):
</span></span><span style=display:flex><span>    X_next <span style=color:#f92672>=</span> xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> dyn_ct(xk, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> X_next
</span></span></code></pre></div><p>Now, replace the <code>for</code> loop from earlier with the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    X_hist[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> integrator_euler(dynamics_ct, X_hist[k, :], U_hist[k, :])
</span></span></code></pre></div><p>Your resulting plot should look exactly the same.</p><h3 id=the-fourth-order-runge-kutta-method>The Fourth-Order Runge-Kutta Method<a hidden class=anchor aria-hidden=true href=#the-fourth-order-runge-kutta-method>#</a></h3><p>Despite its computational efficiency, the explicit Euler method is not ideal for robotics. Higher-order Runge-Kutta methods are generally preferred due to their superior accuracy and stability. The fourth-order Runge-Kutta method (RK4) is one of the most popular.</p><p>For brevity, I won&rsquo;t explain how/why it works here, but you can try it out by replacing the <code>integrator_euler()</code> function with the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>integrator_rk4</span>(dyn_ct, xk, uk):
</span></span><span style=display:flex><span>    f1 <span style=color:#f92672>=</span> dyn_ct(xk, uk)
</span></span><span style=display:flex><span>    f2 <span style=color:#f92672>=</span> dyn_ct(xk <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> dt <span style=color:#f92672>*</span> f1, uk)
</span></span><span style=display:flex><span>    f3 <span style=color:#f92672>=</span> dyn_ct(xk <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> dt <span style=color:#f92672>*</span> f2, uk)
</span></span><span style=display:flex><span>    f4 <span style=color:#f92672>=</span> dyn_ct(xk <span style=color:#f92672>+</span> dt <span style=color:#f92672>*</span> f3, uk)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> xk <span style=color:#f92672>+</span> (dt <span style=color:#f92672>/</span> <span style=color:#ae81ff>6.0</span>) <span style=color:#f92672>*</span> (f1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> f2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> f3 <span style=color:#f92672>+</span> f4)
</span></span></code></pre></div><p>For such a simple setup, you won&rsquo;t notice much of a difference between these methods until you turn the timestep size way up.
The following plot compares all three methods covered here using a timestep size of a tenth of a second.</p><p><img loading=lazy src=/images/2024-02-18/comparison_plot.png></p><p>The expm result should be taken as &ldquo;ground truth&rdquo;. As you can see, the explicit Euler method visibly diverges from &ldquo;truth&rdquo;, but it is still not possible to distinguish the RK4 results from expm.</p><h2 id=adding-control>Adding Control<a hidden class=anchor aria-hidden=true href=#adding-control>#</a></h2><p>One more thing. After the first half a second, let&rsquo;s add a 1000N force to the control vector applied over the course of a quarter second and see what happens.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span>  <span style=color:#75715e># number of timesteps</span>
</span></span><span style=display:flex><span>X_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N, n_x))  <span style=color:#75715e># array of state vectors for each timestep</span>
</span></span><span style=display:flex><span>X_hist[<span style=color:#ae81ff>0</span>, :] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])
</span></span><span style=display:flex><span>U_hist <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, n_u)) <span style=color:#75715e># array of control vectors for each timestep</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>U_hist[<span style=color:#ae81ff>500</span>:<span style=color:#ae81ff>750</span>, :] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># HERE!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    X_hist[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, :] <span style=color:#f92672>=</span> dynamics_dt(X_hist[k, :], U_hist[k, :])
</span></span></code></pre></div><p><img loading=lazy src=/images/2024-02-18/added_force_plot.png></p><p>Whee!</p><h2 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h2><p>In the next part of this series, I will cover how contact is simulated, so that the point mass can bounce off the ground.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bbokser.github.io/tags/control/>Control</a></li></ul><nav class=paginav><a class=prev href=https://bbokser.github.io/posts/2024-06-12/><span class=title>« Prev</span><br><span>Reviving an MP3 Player from 2007</span>
</a><a class=next href=https://bbokser.github.io/posts/2023-04-17/><span class=title>Next »</span><br><span>On the Optimal Design of Cantilever Beams</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on x" href="https://x.com/intent/tweet/?text=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f&amp;hashtags=control"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f&amp;title=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses&amp;summary=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses&amp;source=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f&title=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on whatsapp" href="https://api.whatsapp.com/send?text=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses%20-%20https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on telegram" href="https://telegram.me/share/url?text=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses&amp;url=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Intro to Robot Simulation, Part 1: Point Masses on ycombinator" href="https://news.ycombinator.com/submitlink?t=Intro%20to%20Robot%20Simulation%2c%20Part%201%3a%20Point%20Masses&u=https%3a%2f%2fbbokser.github.io%2fposts%2f2024-02-18%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div class=giscus><script>function getGiscusTheme(){const e=localStorage.getItem("pref-theme"),t=e==null||e=="light"?"light":"dark";return t}function setGiscusTheme(){function e(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}e({setConfig:{theme:getGiscusTheme()=="light"?"dark":"light"}})}const attrs={src:"https://giscus.app/client.js","data-repo":"bbokser/bbokser.github.io","data-repo-id":"R_kgDOGxN6Pg","data-category":"Announcements","data-category-id":"DIC_kwDOIWVKbs4CSTz_","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getGiscusTheme(),"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(attrs).forEach(([e,t])=>giscusScript.setAttribute(e,t)),document.body.appendChild(giscusScript);const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",setGiscusTheme)</script><noscript>Please enable JavaScript to view the comments</noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://bbokser.github.io/>Ben Bokser's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>