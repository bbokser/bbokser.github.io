<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Control on Ben Bokser&#39;s Blog</title>
    <link>https://bbokser.github.io/tags/control/</link>
    <description>Recent content in Control on Ben Bokser&#39;s Blog</description>
    <generator>Hugo -- 0.141.0</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://bbokser.github.io/tags/control/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intro to Robot Simulation, Part 3: Friction</title>
      <link>https://bbokser.github.io/posts/2025-01-20/</link>
      <pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2025-01-20/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;In this post, we will add 1-dimensional coulomb friction to our simulation.&lt;/p&gt;
&lt;p&gt;First off, we&amp;rsquo;re going to need to allow movement in the horizontal direction.
Our new state-space system will be a 2-dimensional system subject to both horizontal and vertical forces.&lt;/p&gt;
 
$$
\begin{equation}
\underbrace{\begin{bmatrix} \dot{x} \\ \dot{z} \\ \ddot{x} \\ \ddot{z} \end{bmatrix}}_{\dot{X}} = 
\underbrace{\begin{bmatrix}
	0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
    0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}}_A
\underbrace{\begin{bmatrix}
    x \\
    z \\
    \dot{x} \\ 
    \dot{z} 
\end{bmatrix}}_X 
&amp;#43; \underbrace{\begin{bmatrix} 
    0 &amp;amp; 0 \\
    0 &amp;amp; 0 \\ 
    \frac{1}{m} &amp;amp; 0 \\
    0 &amp;amp; \frac{1}{m}
\end{bmatrix}}_B 
\underbrace{\begin{bmatrix}
    f_x \\
    f_z
\end{bmatrix}}_F 
&amp;#43; \underbrace{\begin{bmatrix} 
    0 \\
    0 \\
    0 \\
    -9.81 
\end{bmatrix}}_G
\end{equation}
$$
&lt;h2 id=&#34;modeling-friction&#34;&gt;Modeling Friction&lt;/h2&gt;
&lt;p&gt;For 1-dimensional Coulomb friction, our friction force, $f_x$, is related to our vertical force $f_z$ by the following equation.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro to Robot Simulation, Part 2: Contact</title>
      <link>https://bbokser.github.io/posts/2024-12-31/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2024-12-31/</guid>
      <description>&lt;p&gt;Okay, so we can simulate a floating point mass subject to arbitrary forces.
Let&amp;rsquo;s now think about what happens when our point mass hits the ground.&lt;/p&gt;
&lt;p&gt;Assuming 100% stiff, inelastic impact, we would get the following position, velocity, and acceleration trajectories:&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://bbokser.github.io/images/2024-12-31/impact.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Notably, the acceleration at impact approaches infinity, which would be very difficult to simulate&amp;ndash;it would require infinitesimal timesteps.
Of course, in reality there is no such thing as a perfectly stiff and inelastic collision,
but in the field of robotics we are often concerned with relatively stiff collisions which cause decelerations on the order of microseconds.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro to Robot Simulation, Part 1: Point Masses</title>
      <link>https://bbokser.github.io/posts/2024-02-18/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2024-02-18/</guid>
      <description>&lt;p&gt;So, you want to write your own dynamic robot simulation from scratch.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with one of the simplest possible dynamical systems: a vertically constrained point mass.
Think of it as a rocket locked to a linear rail.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://bbokser.github.io/images/2024-02-18/rocket.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;The rocket cannot rotate or translate laterally; it can only move up or down,
and can it only control this by either exerting an upward force or letting gravity take its course.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deriving the Manipulator Equations from the Euler-Lagrange Equation</title>
      <link>https://bbokser.github.io/posts/2023-03-06/</link>
      <pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2023-03-06/</guid>
      <description>&lt;p&gt;The equations of motion for a robot manipulator and their relationship to the Euler-Lagrange equation are well known in the field of robotics, and yet I was unable to find a single source that provides the derivation. I suppose it&amp;rsquo;s one of those &amp;ldquo;the solution is trivial and is left as an exercise to the reader&amp;rdquo; situations. As such, I&amp;rsquo;m providing one here for dummies like me who need it spelled out step-by-step.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Stable Bipedal Walking in Simulation</title>
      <link>https://bbokser.github.io/posts/2021-07-20/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2021-07-20/</guid>
      <description>&lt;p&gt;In late 2019, I designed a custom QDD gearbox. Then I designed a bipedal robot with said gearing. By early 2020 I was spending about an hour per day after work coding a controller for the bipedal robot I had designed. In that time I learned a great deal of Python, and my controls proficiency skyrocketed. Then I started grad school and had to put this project on hold for about six months. But now, over a year and a half later, I&amp;rsquo;ve finally achieved stable bipedal walking in simulation.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Model Predictive Control for a Legged Robot</title>
      <link>https://bbokser.github.io/posts/2020-10-12/</link>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2020-10-12/</guid>
      <description>&lt;p&gt;I have recently implemented a model predictive controller (MPC) to calculate the necessary reaction forces for a legged robot. The work presented here is based on &lt;a href=&#34;https://arxiv.org/pdf/1909.06586.pdf&#34;&gt;this&lt;/a&gt; paper by Kim et al. If you don&amp;rsquo;t know what model predictive control is, I recommend &lt;a href=&#34;https://youtu.be/YwodGM2eoy4&#34;&gt;this&lt;/a&gt; excellent explanation by Steve Brunton. I also found &lt;a href=&#34;https://youtu.be/RrnkPrcpyEA&#34;&gt;this&lt;/a&gt; guide to model predictive control with CasADI to be extremely helpful. CasADi is an open source nonlinear optimization tool which I&amp;rsquo;m using for MPC.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Solving for the Jacobians of a Robot Leg</title>
      <link>https://bbokser.github.io/posts/2020-05-04/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      <guid>https://bbokser.github.io/posts/2020-05-04/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m currently working on the Python &lt;a href=&#34;https://github.com/bbokser/spryped&#34;&gt;code&lt;/a&gt; to control a simulated version of my latest bipedal robot design in PyBullet. My focus over the past few weeks was getting the operational space control to work (many thanks to Travis DeWolf&amp;rsquo;s incredibly helpful &lt;a href=&#34;https://studywolf.wordpress.com/site-index/&#34;&gt;blog&lt;/a&gt;). After finally getting it to work properly, I have decided to share my math in the hopes of providing a useful example for anyone else having trouble with this. There really aren&amp;rsquo;t enough resources on the internet that explain this in a succinct manner.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
